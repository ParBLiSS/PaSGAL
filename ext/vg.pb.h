// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vg.proto

#ifndef PROTOBUF_INCLUDED_vg_2eproto
#define PROTOBUF_INCLUDED_vg_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/struct.pb.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_vg_2eproto 

namespace protobuf_vg_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[23];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_vg_2eproto
namespace vg {
class Alignment;
class AlignmentDefaultTypeInternal;
extern AlignmentDefaultTypeInternal _Alignment_default_instance_;
class BasePileup;
class BasePileupDefaultTypeInternal;
extern BasePileupDefaultTypeInternal _BasePileup_default_instance_;
class Edge;
class EdgeDefaultTypeInternal;
extern EdgeDefaultTypeInternal _Edge_default_instance_;
class EdgePileup;
class EdgePileupDefaultTypeInternal;
extern EdgePileupDefaultTypeInternal _EdgePileup_default_instance_;
class Edit;
class EditDefaultTypeInternal;
extern EditDefaultTypeInternal _Edit_default_instance_;
class Genotype;
class GenotypeDefaultTypeInternal;
extern GenotypeDefaultTypeInternal _Genotype_default_instance_;
class Graph;
class GraphDefaultTypeInternal;
extern GraphDefaultTypeInternal _Graph_default_instance_;
class KmerMatch;
class KmerMatchDefaultTypeInternal;
extern KmerMatchDefaultTypeInternal _KmerMatch_default_instance_;
class LocationSupport;
class LocationSupportDefaultTypeInternal;
extern LocationSupportDefaultTypeInternal _LocationSupport_default_instance_;
class Locus;
class LocusDefaultTypeInternal;
extern LocusDefaultTypeInternal _Locus_default_instance_;
class Mapping;
class MappingDefaultTypeInternal;
extern MappingDefaultTypeInternal _Mapping_default_instance_;
class MultipathAlignment;
class MultipathAlignmentDefaultTypeInternal;
extern MultipathAlignmentDefaultTypeInternal _MultipathAlignment_default_instance_;
class Node;
class NodeDefaultTypeInternal;
extern NodeDefaultTypeInternal _Node_default_instance_;
class NodePileup;
class NodePileupDefaultTypeInternal;
extern NodePileupDefaultTypeInternal _NodePileup_default_instance_;
class Path;
class PathDefaultTypeInternal;
extern PathDefaultTypeInternal _Path_default_instance_;
class Pileup;
class PileupDefaultTypeInternal;
extern PileupDefaultTypeInternal _Pileup_default_instance_;
class Position;
class PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class Snarl;
class SnarlDefaultTypeInternal;
extern SnarlDefaultTypeInternal _Snarl_default_instance_;
class SnarlTraversal;
class SnarlTraversalDefaultTypeInternal;
extern SnarlTraversalDefaultTypeInternal _SnarlTraversal_default_instance_;
class Subpath;
class SubpathDefaultTypeInternal;
extern SubpathDefaultTypeInternal _Subpath_default_instance_;
class Support;
class SupportDefaultTypeInternal;
extern SupportDefaultTypeInternal _Support_default_instance_;
class Translation;
class TranslationDefaultTypeInternal;
extern TranslationDefaultTypeInternal _Translation_default_instance_;
class Visit;
class VisitDefaultTypeInternal;
extern VisitDefaultTypeInternal _Visit_default_instance_;
}  // namespace vg
namespace google {
namespace protobuf {
template<> ::vg::Alignment* Arena::CreateMaybeMessage<::vg::Alignment>(Arena*);
template<> ::vg::BasePileup* Arena::CreateMaybeMessage<::vg::BasePileup>(Arena*);
template<> ::vg::Edge* Arena::CreateMaybeMessage<::vg::Edge>(Arena*);
template<> ::vg::EdgePileup* Arena::CreateMaybeMessage<::vg::EdgePileup>(Arena*);
template<> ::vg::Edit* Arena::CreateMaybeMessage<::vg::Edit>(Arena*);
template<> ::vg::Genotype* Arena::CreateMaybeMessage<::vg::Genotype>(Arena*);
template<> ::vg::Graph* Arena::CreateMaybeMessage<::vg::Graph>(Arena*);
template<> ::vg::KmerMatch* Arena::CreateMaybeMessage<::vg::KmerMatch>(Arena*);
template<> ::vg::LocationSupport* Arena::CreateMaybeMessage<::vg::LocationSupport>(Arena*);
template<> ::vg::Locus* Arena::CreateMaybeMessage<::vg::Locus>(Arena*);
template<> ::vg::Mapping* Arena::CreateMaybeMessage<::vg::Mapping>(Arena*);
template<> ::vg::MultipathAlignment* Arena::CreateMaybeMessage<::vg::MultipathAlignment>(Arena*);
template<> ::vg::Node* Arena::CreateMaybeMessage<::vg::Node>(Arena*);
template<> ::vg::NodePileup* Arena::CreateMaybeMessage<::vg::NodePileup>(Arena*);
template<> ::vg::Path* Arena::CreateMaybeMessage<::vg::Path>(Arena*);
template<> ::vg::Pileup* Arena::CreateMaybeMessage<::vg::Pileup>(Arena*);
template<> ::vg::Position* Arena::CreateMaybeMessage<::vg::Position>(Arena*);
template<> ::vg::Snarl* Arena::CreateMaybeMessage<::vg::Snarl>(Arena*);
template<> ::vg::SnarlTraversal* Arena::CreateMaybeMessage<::vg::SnarlTraversal>(Arena*);
template<> ::vg::Subpath* Arena::CreateMaybeMessage<::vg::Subpath>(Arena*);
template<> ::vg::Support* Arena::CreateMaybeMessage<::vg::Support>(Arena*);
template<> ::vg::Translation* Arena::CreateMaybeMessage<::vg::Translation>(Arena*);
template<> ::vg::Visit* Arena::CreateMaybeMessage<::vg::Visit>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace vg {

enum SnarlType {
  UNCLASSIFIED = 0,
  ULTRABUBBLE = 1,
  UNARY = 2,
  SnarlType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SnarlType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SnarlType_IsValid(int value);
const SnarlType SnarlType_MIN = UNCLASSIFIED;
const SnarlType SnarlType_MAX = UNARY;
const int SnarlType_ARRAYSIZE = SnarlType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SnarlType_descriptor();
inline const ::std::string& SnarlType_Name(SnarlType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SnarlType_descriptor(), value);
}
inline bool SnarlType_Parse(
    const ::std::string& name, SnarlType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SnarlType>(
    SnarlType_descriptor(), name, value);
}
// ===================================================================

class Graph : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.Graph) */ {
 public:
  Graph();
  virtual ~Graph();

  Graph(const Graph& from);

  inline Graph& operator=(const Graph& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Graph(Graph&& from) noexcept
    : Graph() {
    *this = ::std::move(from);
  }

  inline Graph& operator=(Graph&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Graph& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Graph* internal_default_instance() {
    return reinterpret_cast<const Graph*>(
               &_Graph_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Graph* other);
  friend void swap(Graph& a, Graph& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Graph* New() const final {
    return CreateMaybeMessage<Graph>(NULL);
  }

  Graph* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Graph>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Graph& from);
  void MergeFrom(const Graph& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Graph* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vg.Node node = 1;
  int node_size() const;
  void clear_node();
  static const int kNodeFieldNumber = 1;
  ::vg::Node* mutable_node(int index);
  ::google::protobuf::RepeatedPtrField< ::vg::Node >*
      mutable_node();
  const ::vg::Node& node(int index) const;
  ::vg::Node* add_node();
  const ::google::protobuf::RepeatedPtrField< ::vg::Node >&
      node() const;

  // repeated .vg.Edge edge = 2;
  int edge_size() const;
  void clear_edge();
  static const int kEdgeFieldNumber = 2;
  ::vg::Edge* mutable_edge(int index);
  ::google::protobuf::RepeatedPtrField< ::vg::Edge >*
      mutable_edge();
  const ::vg::Edge& edge(int index) const;
  ::vg::Edge* add_edge();
  const ::google::protobuf::RepeatedPtrField< ::vg::Edge >&
      edge() const;

  // repeated .vg.Path path = 3;
  int path_size() const;
  void clear_path();
  static const int kPathFieldNumber = 3;
  ::vg::Path* mutable_path(int index);
  ::google::protobuf::RepeatedPtrField< ::vg::Path >*
      mutable_path();
  const ::vg::Path& path(int index) const;
  ::vg::Path* add_path();
  const ::google::protobuf::RepeatedPtrField< ::vg::Path >&
      path() const;

  // @@protoc_insertion_point(class_scope:vg.Graph)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vg::Node > node_;
  ::google::protobuf::RepeatedPtrField< ::vg::Edge > edge_;
  ::google::protobuf::RepeatedPtrField< ::vg::Path > path_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Node : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.Node) */ {
 public:
  Node();
  virtual ~Node();

  Node(const Node& from);

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Node(Node&& from) noexcept
    : Node() {
    *this = ::std::move(from);
  }

  inline Node& operator=(Node&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Node& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
               &_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Node* other);
  friend void swap(Node& a, Node& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Node* New() const final {
    return CreateMaybeMessage<Node>(NULL);
  }

  Node* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Node>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sequence = 1;
  void clear_sequence();
  static const int kSequenceFieldNumber = 1;
  const ::std::string& sequence() const;
  void set_sequence(const ::std::string& value);
  #if LANG_CXX11
  void set_sequence(::std::string&& value);
  #endif
  void set_sequence(const char* value);
  void set_sequence(const char* value, size_t size);
  ::std::string* mutable_sequence();
  ::std::string* release_sequence();
  void set_allocated_sequence(::std::string* sequence);

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // int64 id = 3;
  void clear_id();
  static const int kIdFieldNumber = 3;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:vg.Node)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr sequence_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int64 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Edge : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.Edge) */ {
 public:
  Edge();
  virtual ~Edge();

  Edge(const Edge& from);

  inline Edge& operator=(const Edge& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Edge(Edge&& from) noexcept
    : Edge() {
    *this = ::std::move(from);
  }

  inline Edge& operator=(Edge&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Edge& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Edge* internal_default_instance() {
    return reinterpret_cast<const Edge*>(
               &_Edge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Edge* other);
  friend void swap(Edge& a, Edge& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Edge* New() const final {
    return CreateMaybeMessage<Edge>(NULL);
  }

  Edge* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Edge>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Edge& from);
  void MergeFrom(const Edge& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Edge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 from = 1;
  void clear_from();
  static const int kFromFieldNumber = 1;
  ::google::protobuf::int64 from() const;
  void set_from(::google::protobuf::int64 value);

  // int64 to = 2;
  void clear_to();
  static const int kToFieldNumber = 2;
  ::google::protobuf::int64 to() const;
  void set_to(::google::protobuf::int64 value);

  // bool from_start = 3;
  void clear_from_start();
  static const int kFromStartFieldNumber = 3;
  bool from_start() const;
  void set_from_start(bool value);

  // bool to_end = 4;
  void clear_to_end();
  static const int kToEndFieldNumber = 4;
  bool to_end() const;
  void set_to_end(bool value);

  // int32 overlap = 5;
  void clear_overlap();
  static const int kOverlapFieldNumber = 5;
  ::google::protobuf::int32 overlap() const;
  void set_overlap(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vg.Edge)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 from_;
  ::google::protobuf::int64 to_;
  bool from_start_;
  bool to_end_;
  ::google::protobuf::int32 overlap_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Edit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.Edit) */ {
 public:
  Edit();
  virtual ~Edit();

  Edit(const Edit& from);

  inline Edit& operator=(const Edit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Edit(Edit&& from) noexcept
    : Edit() {
    *this = ::std::move(from);
  }

  inline Edit& operator=(Edit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Edit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Edit* internal_default_instance() {
    return reinterpret_cast<const Edit*>(
               &_Edit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Edit* other);
  friend void swap(Edit& a, Edit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Edit* New() const final {
    return CreateMaybeMessage<Edit>(NULL);
  }

  Edit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Edit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Edit& from);
  void MergeFrom(const Edit& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Edit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sequence = 3;
  void clear_sequence();
  static const int kSequenceFieldNumber = 3;
  const ::std::string& sequence() const;
  void set_sequence(const ::std::string& value);
  #if LANG_CXX11
  void set_sequence(::std::string&& value);
  #endif
  void set_sequence(const char* value);
  void set_sequence(const char* value, size_t size);
  ::std::string* mutable_sequence();
  ::std::string* release_sequence();
  void set_allocated_sequence(::std::string* sequence);

  // int32 from_length = 1;
  void clear_from_length();
  static const int kFromLengthFieldNumber = 1;
  ::google::protobuf::int32 from_length() const;
  void set_from_length(::google::protobuf::int32 value);

  // int32 to_length = 2;
  void clear_to_length();
  static const int kToLengthFieldNumber = 2;
  ::google::protobuf::int32 to_length() const;
  void set_to_length(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vg.Edit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr sequence_;
  ::google::protobuf::int32 from_length_;
  ::google::protobuf::int32 to_length_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Mapping : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.Mapping) */ {
 public:
  Mapping();
  virtual ~Mapping();

  Mapping(const Mapping& from);

  inline Mapping& operator=(const Mapping& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Mapping(Mapping&& from) noexcept
    : Mapping() {
    *this = ::std::move(from);
  }

  inline Mapping& operator=(Mapping&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Mapping& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Mapping* internal_default_instance() {
    return reinterpret_cast<const Mapping*>(
               &_Mapping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Mapping* other);
  friend void swap(Mapping& a, Mapping& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Mapping* New() const final {
    return CreateMaybeMessage<Mapping>(NULL);
  }

  Mapping* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Mapping>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Mapping& from);
  void MergeFrom(const Mapping& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mapping* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vg.Edit edit = 2;
  int edit_size() const;
  void clear_edit();
  static const int kEditFieldNumber = 2;
  ::vg::Edit* mutable_edit(int index);
  ::google::protobuf::RepeatedPtrField< ::vg::Edit >*
      mutable_edit();
  const ::vg::Edit& edit(int index) const;
  ::vg::Edit* add_edit();
  const ::google::protobuf::RepeatedPtrField< ::vg::Edit >&
      edit() const;

  // .vg.Position position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  private:
  const ::vg::Position& _internal_position() const;
  public:
  const ::vg::Position& position() const;
  ::vg::Position* release_position();
  ::vg::Position* mutable_position();
  void set_allocated_position(::vg::Position* position);

  // int64 rank = 5;
  void clear_rank();
  static const int kRankFieldNumber = 5;
  ::google::protobuf::int64 rank() const;
  void set_rank(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:vg.Mapping)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vg::Edit > edit_;
  ::vg::Position* position_;
  ::google::protobuf::int64 rank_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Position : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.Position) */ {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(Position&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Position& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Position* other);
  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Position* New() const final {
    return CreateMaybeMessage<Position>(NULL);
  }

  Position* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 5;
  void clear_name();
  static const int kNameFieldNumber = 5;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // int64 node_id = 1;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  ::google::protobuf::int64 node_id() const;
  void set_node_id(::google::protobuf::int64 value);

  // int64 offset = 2;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  ::google::protobuf::int64 offset() const;
  void set_offset(::google::protobuf::int64 value);

  // bool is_reverse = 4;
  void clear_is_reverse();
  static const int kIsReverseFieldNumber = 4;
  bool is_reverse() const;
  void set_is_reverse(bool value);

  // @@protoc_insertion_point(class_scope:vg.Position)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int64 node_id_;
  ::google::protobuf::int64 offset_;
  bool is_reverse_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Path : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.Path) */ {
 public:
  Path();
  virtual ~Path();

  Path(const Path& from);

  inline Path& operator=(const Path& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Path(Path&& from) noexcept
    : Path() {
    *this = ::std::move(from);
  }

  inline Path& operator=(Path&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Path& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Path* internal_default_instance() {
    return reinterpret_cast<const Path*>(
               &_Path_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Path* other);
  friend void swap(Path& a, Path& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Path* New() const final {
    return CreateMaybeMessage<Path>(NULL);
  }

  Path* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Path>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Path& from);
  void MergeFrom(const Path& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Path* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vg.Mapping mapping = 2;
  int mapping_size() const;
  void clear_mapping();
  static const int kMappingFieldNumber = 2;
  ::vg::Mapping* mutable_mapping(int index);
  ::google::protobuf::RepeatedPtrField< ::vg::Mapping >*
      mutable_mapping();
  const ::vg::Mapping& mapping(int index) const;
  ::vg::Mapping* add_mapping();
  const ::google::protobuf::RepeatedPtrField< ::vg::Mapping >&
      mapping() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // int64 length = 4;
  void clear_length();
  static const int kLengthFieldNumber = 4;
  ::google::protobuf::int64 length() const;
  void set_length(::google::protobuf::int64 value);

  // bool is_circular = 3;
  void clear_is_circular();
  static const int kIsCircularFieldNumber = 3;
  bool is_circular() const;
  void set_is_circular(bool value);

  // @@protoc_insertion_point(class_scope:vg.Path)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vg::Mapping > mapping_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int64 length_;
  bool is_circular_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Alignment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.Alignment) */ {
 public:
  Alignment();
  virtual ~Alignment();

  Alignment(const Alignment& from);

  inline Alignment& operator=(const Alignment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Alignment(Alignment&& from) noexcept
    : Alignment() {
    *this = ::std::move(from);
  }

  inline Alignment& operator=(Alignment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Alignment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Alignment* internal_default_instance() {
    return reinterpret_cast<const Alignment*>(
               &_Alignment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Alignment* other);
  friend void swap(Alignment& a, Alignment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Alignment* New() const final {
    return CreateMaybeMessage<Alignment>(NULL);
  }

  Alignment* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Alignment>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Alignment& from);
  void MergeFrom(const Alignment& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Alignment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vg.Path fragment = 17;
  int fragment_size() const;
  void clear_fragment();
  static const int kFragmentFieldNumber = 17;
  ::vg::Path* mutable_fragment(int index);
  ::google::protobuf::RepeatedPtrField< ::vg::Path >*
      mutable_fragment();
  const ::vg::Path& fragment(int index) const;
  ::vg::Path* add_fragment();
  const ::google::protobuf::RepeatedPtrField< ::vg::Path >&
      fragment() const;

  // repeated .vg.Locus locus = 18;
  int locus_size() const;
  void clear_locus();
  static const int kLocusFieldNumber = 18;
  ::vg::Locus* mutable_locus(int index);
  ::google::protobuf::RepeatedPtrField< ::vg::Locus >*
      mutable_locus();
  const ::vg::Locus& locus(int index) const;
  ::vg::Locus* add_locus();
  const ::google::protobuf::RepeatedPtrField< ::vg::Locus >&
      locus() const;

  // repeated .vg.Position refpos = 19;
  int refpos_size() const;
  void clear_refpos();
  static const int kRefposFieldNumber = 19;
  ::vg::Position* mutable_refpos(int index);
  ::google::protobuf::RepeatedPtrField< ::vg::Position >*
      mutable_refpos();
  const ::vg::Position& refpos(int index) const;
  ::vg::Position* add_refpos();
  const ::google::protobuf::RepeatedPtrField< ::vg::Position >&
      refpos() const;

  // repeated int32 secondary_score = 29;
  int secondary_score_size() const;
  void clear_secondary_score();
  static const int kSecondaryScoreFieldNumber = 29;
  ::google::protobuf::int32 secondary_score(int index) const;
  void set_secondary_score(int index, ::google::protobuf::int32 value);
  void add_secondary_score(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      secondary_score() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_secondary_score();

  // string sequence = 1;
  void clear_sequence();
  static const int kSequenceFieldNumber = 1;
  const ::std::string& sequence() const;
  void set_sequence(const ::std::string& value);
  #if LANG_CXX11
  void set_sequence(::std::string&& value);
  #endif
  void set_sequence(const char* value);
  void set_sequence(const char* value, size_t size);
  ::std::string* mutable_sequence();
  ::std::string* release_sequence();
  void set_allocated_sequence(::std::string* sequence);

  // string name = 3;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // bytes quality = 4;
  void clear_quality();
  static const int kQualityFieldNumber = 4;
  const ::std::string& quality() const;
  void set_quality(const ::std::string& value);
  #if LANG_CXX11
  void set_quality(::std::string&& value);
  #endif
  void set_quality(const char* value);
  void set_quality(const void* value, size_t size);
  ::std::string* mutable_quality();
  ::std::string* release_quality();
  void set_allocated_quality(::std::string* quality);

  // string sample_name = 9;
  void clear_sample_name();
  static const int kSampleNameFieldNumber = 9;
  const ::std::string& sample_name() const;
  void set_sample_name(const ::std::string& value);
  #if LANG_CXX11
  void set_sample_name(::std::string&& value);
  #endif
  void set_sample_name(const char* value);
  void set_sample_name(const char* value, size_t size);
  ::std::string* mutable_sample_name();
  ::std::string* release_sample_name();
  void set_allocated_sample_name(::std::string* sample_name);

  // string read_group = 10;
  void clear_read_group();
  static const int kReadGroupFieldNumber = 10;
  const ::std::string& read_group() const;
  void set_read_group(const ::std::string& value);
  #if LANG_CXX11
  void set_read_group(::std::string&& value);
  #endif
  void set_read_group(const char* value);
  void set_read_group(const char* value, size_t size);
  ::std::string* mutable_read_group();
  ::std::string* release_read_group();
  void set_allocated_read_group(::std::string* read_group);

  // string fragment_length_distribution = 32;
  void clear_fragment_length_distribution();
  static const int kFragmentLengthDistributionFieldNumber = 32;
  const ::std::string& fragment_length_distribution() const;
  void set_fragment_length_distribution(const ::std::string& value);
  #if LANG_CXX11
  void set_fragment_length_distribution(::std::string&& value);
  #endif
  void set_fragment_length_distribution(const char* value);
  void set_fragment_length_distribution(const char* value, size_t size);
  ::std::string* mutable_fragment_length_distribution();
  ::std::string* release_fragment_length_distribution();
  void set_allocated_fragment_length_distribution(::std::string* fragment_length_distribution);

  // .vg.Path path = 2;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 2;
  private:
  const ::vg::Path& _internal_path() const;
  public:
  const ::vg::Path& path() const;
  ::vg::Path* release_path();
  ::vg::Path* mutable_path();
  void set_allocated_path(::vg::Path* path);

  // .vg.Alignment fragment_prev = 11;
  bool has_fragment_prev() const;
  void clear_fragment_prev();
  static const int kFragmentPrevFieldNumber = 11;
  private:
  const ::vg::Alignment& _internal_fragment_prev() const;
  public:
  const ::vg::Alignment& fragment_prev() const;
  ::vg::Alignment* release_fragment_prev();
  ::vg::Alignment* mutable_fragment_prev();
  void set_allocated_fragment_prev(::vg::Alignment* fragment_prev);

  // .vg.Alignment fragment_next = 12;
  bool has_fragment_next() const;
  void clear_fragment_next();
  static const int kFragmentNextFieldNumber = 12;
  private:
  const ::vg::Alignment& _internal_fragment_next() const;
  public:
  const ::vg::Alignment& fragment_next() const;
  ::vg::Alignment* release_fragment_next();
  ::vg::Alignment* mutable_fragment_next();
  void set_allocated_fragment_next(::vg::Alignment* fragment_next);

  // .vg.Position to_correct = 36;
  bool has_to_correct() const;
  void clear_to_correct();
  static const int kToCorrectFieldNumber = 36;
  private:
  const ::vg::Position& _internal_to_correct() const;
  public:
  const ::vg::Position& to_correct() const;
  ::vg::Position* release_to_correct();
  ::vg::Position* mutable_to_correct();
  void set_allocated_to_correct(::vg::Position* to_correct);

  // .google.protobuf.Struct annotation = 100;
  bool has_annotation() const;
  void clear_annotation();
  static const int kAnnotationFieldNumber = 100;
  private:
  const ::google::protobuf::Struct& _internal_annotation() const;
  public:
  const ::google::protobuf::Struct& annotation() const;
  ::google::protobuf::Struct* release_annotation();
  ::google::protobuf::Struct* mutable_annotation();
  void set_allocated_annotation(::google::protobuf::Struct* annotation);

  // int32 mapping_quality = 5;
  void clear_mapping_quality();
  static const int kMappingQualityFieldNumber = 5;
  ::google::protobuf::int32 mapping_quality() const;
  void set_mapping_quality(::google::protobuf::int32 value);

  // int32 score = 6;
  void clear_score();
  static const int kScoreFieldNumber = 6;
  ::google::protobuf::int32 score() const;
  void set_score(::google::protobuf::int32 value);

  // double identity = 16;
  void clear_identity();
  static const int kIdentityFieldNumber = 16;
  double identity() const;
  void set_identity(double value);

  // int32 query_position = 7;
  void clear_query_position();
  static const int kQueryPositionFieldNumber = 7;
  ::google::protobuf::int32 query_position() const;
  void set_query_position(::google::protobuf::int32 value);

  // bool is_secondary = 15;
  void clear_is_secondary();
  static const int kIsSecondaryFieldNumber = 15;
  bool is_secondary() const;
  void set_is_secondary(bool value);

  // bool read_paired = 20;
  void clear_read_paired();
  static const int kReadPairedFieldNumber = 20;
  bool read_paired() const;
  void set_read_paired(bool value);

  // bool read_mapped = 21;
  void clear_read_mapped();
  static const int kReadMappedFieldNumber = 21;
  bool read_mapped() const;
  void set_read_mapped(bool value);

  // bool mate_unmapped = 22;
  void clear_mate_unmapped();
  static const int kMateUnmappedFieldNumber = 22;
  bool mate_unmapped() const;
  void set_mate_unmapped(bool value);

  // double uniqueness = 27;
  void clear_uniqueness();
  static const int kUniquenessFieldNumber = 27;
  double uniqueness() const;
  void set_uniqueness(double value);

  // double correct = 28;
  void clear_correct();
  static const int kCorrectFieldNumber = 28;
  double correct() const;
  void set_correct(double value);

  // bool read_on_reverse_strand = 23;
  void clear_read_on_reverse_strand();
  static const int kReadOnReverseStrandFieldNumber = 23;
  bool read_on_reverse_strand() const;
  void set_read_on_reverse_strand(bool value);

  // bool mate_on_reverse_strand = 24;
  void clear_mate_on_reverse_strand();
  static const int kMateOnReverseStrandFieldNumber = 24;
  bool mate_on_reverse_strand() const;
  void set_mate_on_reverse_strand(bool value);

  // bool soft_clipped = 25;
  void clear_soft_clipped();
  static const int kSoftClippedFieldNumber = 25;
  bool soft_clipped() const;
  void set_soft_clipped(bool value);

  // bool discordant_insert_size = 26;
  void clear_discordant_insert_size();
  static const int kDiscordantInsertSizeFieldNumber = 26;
  bool discordant_insert_size() const;
  void set_discordant_insert_size(bool value);

  // bool mate_mapped_to_disjoint_subgraph = 31;
  void clear_mate_mapped_to_disjoint_subgraph();
  static const int kMateMappedToDisjointSubgraphFieldNumber = 31;
  bool mate_mapped_to_disjoint_subgraph() const;
  void set_mate_mapped_to_disjoint_subgraph(bool value);

  // bool haplotype_scored = 33;
  void clear_haplotype_scored();
  static const int kHaplotypeScoredFieldNumber = 33;
  bool haplotype_scored() const;
  void set_haplotype_scored(bool value);

  // bool correctly_mapped = 37;
  void clear_correctly_mapped();
  static const int kCorrectlyMappedFieldNumber = 37;
  bool correctly_mapped() const;
  void set_correctly_mapped(bool value);

  // double fragment_score = 30;
  void clear_fragment_score();
  static const int kFragmentScoreFieldNumber = 30;
  double fragment_score() const;
  void set_fragment_score(double value);

  // double haplotype_logprob = 34;
  void clear_haplotype_logprob();
  static const int kHaplotypeLogprobFieldNumber = 34;
  double haplotype_logprob() const;
  void set_haplotype_logprob(double value);

  // double time_used = 35;
  void clear_time_used();
  static const int kTimeUsedFieldNumber = 35;
  double time_used() const;
  void set_time_used(double value);

  // @@protoc_insertion_point(class_scope:vg.Alignment)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vg::Path > fragment_;
  ::google::protobuf::RepeatedPtrField< ::vg::Locus > locus_;
  ::google::protobuf::RepeatedPtrField< ::vg::Position > refpos_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > secondary_score_;
  mutable int _secondary_score_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr sequence_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr quality_;
  ::google::protobuf::internal::ArenaStringPtr sample_name_;
  ::google::protobuf::internal::ArenaStringPtr read_group_;
  ::google::protobuf::internal::ArenaStringPtr fragment_length_distribution_;
  ::vg::Path* path_;
  ::vg::Alignment* fragment_prev_;
  ::vg::Alignment* fragment_next_;
  ::vg::Position* to_correct_;
  ::google::protobuf::Struct* annotation_;
  ::google::protobuf::int32 mapping_quality_;
  ::google::protobuf::int32 score_;
  double identity_;
  ::google::protobuf::int32 query_position_;
  bool is_secondary_;
  bool read_paired_;
  bool read_mapped_;
  bool mate_unmapped_;
  double uniqueness_;
  double correct_;
  bool read_on_reverse_strand_;
  bool mate_on_reverse_strand_;
  bool soft_clipped_;
  bool discordant_insert_size_;
  bool mate_mapped_to_disjoint_subgraph_;
  bool haplotype_scored_;
  bool correctly_mapped_;
  double fragment_score_;
  double haplotype_logprob_;
  double time_used_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultipathAlignment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.MultipathAlignment) */ {
 public:
  MultipathAlignment();
  virtual ~MultipathAlignment();

  MultipathAlignment(const MultipathAlignment& from);

  inline MultipathAlignment& operator=(const MultipathAlignment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MultipathAlignment(MultipathAlignment&& from) noexcept
    : MultipathAlignment() {
    *this = ::std::move(from);
  }

  inline MultipathAlignment& operator=(MultipathAlignment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MultipathAlignment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultipathAlignment* internal_default_instance() {
    return reinterpret_cast<const MultipathAlignment*>(
               &_MultipathAlignment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(MultipathAlignment* other);
  friend void swap(MultipathAlignment& a, MultipathAlignment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultipathAlignment* New() const final {
    return CreateMaybeMessage<MultipathAlignment>(NULL);
  }

  MultipathAlignment* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MultipathAlignment>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MultipathAlignment& from);
  void MergeFrom(const MultipathAlignment& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultipathAlignment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vg.Subpath subpath = 6;
  int subpath_size() const;
  void clear_subpath();
  static const int kSubpathFieldNumber = 6;
  ::vg::Subpath* mutable_subpath(int index);
  ::google::protobuf::RepeatedPtrField< ::vg::Subpath >*
      mutable_subpath();
  const ::vg::Subpath& subpath(int index) const;
  ::vg::Subpath* add_subpath();
  const ::google::protobuf::RepeatedPtrField< ::vg::Subpath >&
      subpath() const;

  // repeated uint32 start = 8;
  int start_size() const;
  void clear_start();
  static const int kStartFieldNumber = 8;
  ::google::protobuf::uint32 start(int index) const;
  void set_start(int index, ::google::protobuf::uint32 value);
  void add_start(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      start() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_start();

  // string sequence = 1;
  void clear_sequence();
  static const int kSequenceFieldNumber = 1;
  const ::std::string& sequence() const;
  void set_sequence(const ::std::string& value);
  #if LANG_CXX11
  void set_sequence(::std::string&& value);
  #endif
  void set_sequence(const char* value);
  void set_sequence(const char* value, size_t size);
  ::std::string* mutable_sequence();
  ::std::string* release_sequence();
  void set_allocated_sequence(::std::string* sequence);

  // bytes quality = 2;
  void clear_quality();
  static const int kQualityFieldNumber = 2;
  const ::std::string& quality() const;
  void set_quality(const ::std::string& value);
  #if LANG_CXX11
  void set_quality(::std::string&& value);
  #endif
  void set_quality(const char* value);
  void set_quality(const void* value, size_t size);
  ::std::string* mutable_quality();
  ::std::string* release_quality();
  void set_allocated_quality(::std::string* quality);

  // string name = 3;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string sample_name = 4;
  void clear_sample_name();
  static const int kSampleNameFieldNumber = 4;
  const ::std::string& sample_name() const;
  void set_sample_name(const ::std::string& value);
  #if LANG_CXX11
  void set_sample_name(::std::string&& value);
  #endif
  void set_sample_name(const char* value);
  void set_sample_name(const char* value, size_t size);
  ::std::string* mutable_sample_name();
  ::std::string* release_sample_name();
  void set_allocated_sample_name(::std::string* sample_name);

  // string read_group = 5;
  void clear_read_group();
  static const int kReadGroupFieldNumber = 5;
  const ::std::string& read_group() const;
  void set_read_group(const ::std::string& value);
  #if LANG_CXX11
  void set_read_group(::std::string&& value);
  #endif
  void set_read_group(const char* value);
  void set_read_group(const char* value, size_t size);
  ::std::string* mutable_read_group();
  ::std::string* release_read_group();
  void set_allocated_read_group(::std::string* read_group);

  // string paired_read_name = 9;
  void clear_paired_read_name();
  static const int kPairedReadNameFieldNumber = 9;
  const ::std::string& paired_read_name() const;
  void set_paired_read_name(const ::std::string& value);
  #if LANG_CXX11
  void set_paired_read_name(::std::string&& value);
  #endif
  void set_paired_read_name(const char* value);
  void set_paired_read_name(const char* value, size_t size);
  ::std::string* mutable_paired_read_name();
  ::std::string* release_paired_read_name();
  void set_allocated_paired_read_name(::std::string* paired_read_name);

  // .google.protobuf.Struct annotation = 100;
  bool has_annotation() const;
  void clear_annotation();
  static const int kAnnotationFieldNumber = 100;
  private:
  const ::google::protobuf::Struct& _internal_annotation() const;
  public:
  const ::google::protobuf::Struct& annotation() const;
  ::google::protobuf::Struct* release_annotation();
  ::google::protobuf::Struct* mutable_annotation();
  void set_allocated_annotation(::google::protobuf::Struct* annotation);

  // int32 mapping_quality = 7;
  void clear_mapping_quality();
  static const int kMappingQualityFieldNumber = 7;
  ::google::protobuf::int32 mapping_quality() const;
  void set_mapping_quality(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vg.MultipathAlignment)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vg::Subpath > subpath_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > start_;
  mutable int _start_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr sequence_;
  ::google::protobuf::internal::ArenaStringPtr quality_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr sample_name_;
  ::google::protobuf::internal::ArenaStringPtr read_group_;
  ::google::protobuf::internal::ArenaStringPtr paired_read_name_;
  ::google::protobuf::Struct* annotation_;
  ::google::protobuf::int32 mapping_quality_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Subpath : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.Subpath) */ {
 public:
  Subpath();
  virtual ~Subpath();

  Subpath(const Subpath& from);

  inline Subpath& operator=(const Subpath& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Subpath(Subpath&& from) noexcept
    : Subpath() {
    *this = ::std::move(from);
  }

  inline Subpath& operator=(Subpath&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Subpath& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Subpath* internal_default_instance() {
    return reinterpret_cast<const Subpath*>(
               &_Subpath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Subpath* other);
  friend void swap(Subpath& a, Subpath& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Subpath* New() const final {
    return CreateMaybeMessage<Subpath>(NULL);
  }

  Subpath* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Subpath>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Subpath& from);
  void MergeFrom(const Subpath& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Subpath* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 next = 2;
  int next_size() const;
  void clear_next();
  static const int kNextFieldNumber = 2;
  ::google::protobuf::uint32 next(int index) const;
  void set_next(int index, ::google::protobuf::uint32 value);
  void add_next(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      next() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_next();

  // .vg.Path path = 1;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 1;
  private:
  const ::vg::Path& _internal_path() const;
  public:
  const ::vg::Path& path() const;
  ::vg::Path* release_path();
  ::vg::Path* mutable_path();
  void set_allocated_path(::vg::Path* path);

  // int32 score = 3;
  void clear_score();
  static const int kScoreFieldNumber = 3;
  ::google::protobuf::int32 score() const;
  void set_score(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vg.Subpath)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > next_;
  mutable int _next_cached_byte_size_;
  ::vg::Path* path_;
  ::google::protobuf::int32 score_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KmerMatch : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.KmerMatch) */ {
 public:
  KmerMatch();
  virtual ~KmerMatch();

  KmerMatch(const KmerMatch& from);

  inline KmerMatch& operator=(const KmerMatch& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KmerMatch(KmerMatch&& from) noexcept
    : KmerMatch() {
    *this = ::std::move(from);
  }

  inline KmerMatch& operator=(KmerMatch&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KmerMatch& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KmerMatch* internal_default_instance() {
    return reinterpret_cast<const KmerMatch*>(
               &_KmerMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(KmerMatch* other);
  friend void swap(KmerMatch& a, KmerMatch& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KmerMatch* New() const final {
    return CreateMaybeMessage<KmerMatch>(NULL);
  }

  KmerMatch* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KmerMatch>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KmerMatch& from);
  void MergeFrom(const KmerMatch& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KmerMatch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sequence = 1;
  void clear_sequence();
  static const int kSequenceFieldNumber = 1;
  const ::std::string& sequence() const;
  void set_sequence(const ::std::string& value);
  #if LANG_CXX11
  void set_sequence(::std::string&& value);
  #endif
  void set_sequence(const char* value);
  void set_sequence(const char* value, size_t size);
  ::std::string* mutable_sequence();
  ::std::string* release_sequence();
  void set_allocated_sequence(::std::string* sequence);

  // int64 node_id = 2;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 2;
  ::google::protobuf::int64 node_id() const;
  void set_node_id(::google::protobuf::int64 value);

  // sint32 position = 3;
  void clear_position();
  static const int kPositionFieldNumber = 3;
  ::google::protobuf::int32 position() const;
  void set_position(::google::protobuf::int32 value);

  // bool backward = 4;
  void clear_backward();
  static const int kBackwardFieldNumber = 4;
  bool backward() const;
  void set_backward(bool value);

  // @@protoc_insertion_point(class_scope:vg.KmerMatch)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr sequence_;
  ::google::protobuf::int64 node_id_;
  ::google::protobuf::int32 position_;
  bool backward_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BasePileup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.BasePileup) */ {
 public:
  BasePileup();
  virtual ~BasePileup();

  BasePileup(const BasePileup& from);

  inline BasePileup& operator=(const BasePileup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BasePileup(BasePileup&& from) noexcept
    : BasePileup() {
    *this = ::std::move(from);
  }

  inline BasePileup& operator=(BasePileup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BasePileup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BasePileup* internal_default_instance() {
    return reinterpret_cast<const BasePileup*>(
               &_BasePileup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(BasePileup* other);
  friend void swap(BasePileup& a, BasePileup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BasePileup* New() const final {
    return CreateMaybeMessage<BasePileup>(NULL);
  }

  BasePileup* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BasePileup>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BasePileup& from);
  void MergeFrom(const BasePileup& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BasePileup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string bases = 3;
  void clear_bases();
  static const int kBasesFieldNumber = 3;
  const ::std::string& bases() const;
  void set_bases(const ::std::string& value);
  #if LANG_CXX11
  void set_bases(::std::string&& value);
  #endif
  void set_bases(const char* value);
  void set_bases(const char* value, size_t size);
  ::std::string* mutable_bases();
  ::std::string* release_bases();
  void set_allocated_bases(::std::string* bases);

  // bytes qualities = 4;
  void clear_qualities();
  static const int kQualitiesFieldNumber = 4;
  const ::std::string& qualities() const;
  void set_qualities(const ::std::string& value);
  #if LANG_CXX11
  void set_qualities(::std::string&& value);
  #endif
  void set_qualities(const char* value);
  void set_qualities(const void* value, size_t size);
  ::std::string* mutable_qualities();
  ::std::string* release_qualities();
  void set_allocated_qualities(::std::string* qualities);

  // int32 ref_base = 1;
  void clear_ref_base();
  static const int kRefBaseFieldNumber = 1;
  ::google::protobuf::int32 ref_base() const;
  void set_ref_base(::google::protobuf::int32 value);

  // int32 num_bases = 2;
  void clear_num_bases();
  static const int kNumBasesFieldNumber = 2;
  ::google::protobuf::int32 num_bases() const;
  void set_num_bases(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vg.BasePileup)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr bases_;
  ::google::protobuf::internal::ArenaStringPtr qualities_;
  ::google::protobuf::int32 ref_base_;
  ::google::protobuf::int32 num_bases_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NodePileup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.NodePileup) */ {
 public:
  NodePileup();
  virtual ~NodePileup();

  NodePileup(const NodePileup& from);

  inline NodePileup& operator=(const NodePileup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodePileup(NodePileup&& from) noexcept
    : NodePileup() {
    *this = ::std::move(from);
  }

  inline NodePileup& operator=(NodePileup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodePileup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodePileup* internal_default_instance() {
    return reinterpret_cast<const NodePileup*>(
               &_NodePileup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(NodePileup* other);
  friend void swap(NodePileup& a, NodePileup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodePileup* New() const final {
    return CreateMaybeMessage<NodePileup>(NULL);
  }

  NodePileup* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NodePileup>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NodePileup& from);
  void MergeFrom(const NodePileup& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodePileup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vg.BasePileup base_pileup = 2;
  int base_pileup_size() const;
  void clear_base_pileup();
  static const int kBasePileupFieldNumber = 2;
  ::vg::BasePileup* mutable_base_pileup(int index);
  ::google::protobuf::RepeatedPtrField< ::vg::BasePileup >*
      mutable_base_pileup();
  const ::vg::BasePileup& base_pileup(int index) const;
  ::vg::BasePileup* add_base_pileup();
  const ::google::protobuf::RepeatedPtrField< ::vg::BasePileup >&
      base_pileup() const;

  // int64 node_id = 1;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  ::google::protobuf::int64 node_id() const;
  void set_node_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:vg.NodePileup)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vg::BasePileup > base_pileup_;
  ::google::protobuf::int64 node_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EdgePileup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.EdgePileup) */ {
 public:
  EdgePileup();
  virtual ~EdgePileup();

  EdgePileup(const EdgePileup& from);

  inline EdgePileup& operator=(const EdgePileup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EdgePileup(EdgePileup&& from) noexcept
    : EdgePileup() {
    *this = ::std::move(from);
  }

  inline EdgePileup& operator=(EdgePileup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EdgePileup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EdgePileup* internal_default_instance() {
    return reinterpret_cast<const EdgePileup*>(
               &_EdgePileup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(EdgePileup* other);
  friend void swap(EdgePileup& a, EdgePileup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EdgePileup* New() const final {
    return CreateMaybeMessage<EdgePileup>(NULL);
  }

  EdgePileup* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EdgePileup>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EdgePileup& from);
  void MergeFrom(const EdgePileup& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EdgePileup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes qualities = 4;
  void clear_qualities();
  static const int kQualitiesFieldNumber = 4;
  const ::std::string& qualities() const;
  void set_qualities(const ::std::string& value);
  #if LANG_CXX11
  void set_qualities(::std::string&& value);
  #endif
  void set_qualities(const char* value);
  void set_qualities(const void* value, size_t size);
  ::std::string* mutable_qualities();
  ::std::string* release_qualities();
  void set_allocated_qualities(::std::string* qualities);

  // .vg.Edge edge = 1;
  bool has_edge() const;
  void clear_edge();
  static const int kEdgeFieldNumber = 1;
  private:
  const ::vg::Edge& _internal_edge() const;
  public:
  const ::vg::Edge& edge() const;
  ::vg::Edge* release_edge();
  ::vg::Edge* mutable_edge();
  void set_allocated_edge(::vg::Edge* edge);

  // int32 num_reads = 2;
  void clear_num_reads();
  static const int kNumReadsFieldNumber = 2;
  ::google::protobuf::int32 num_reads() const;
  void set_num_reads(::google::protobuf::int32 value);

  // int32 num_forward_reads = 3;
  void clear_num_forward_reads();
  static const int kNumForwardReadsFieldNumber = 3;
  ::google::protobuf::int32 num_forward_reads() const;
  void set_num_forward_reads(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vg.EdgePileup)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr qualities_;
  ::vg::Edge* edge_;
  ::google::protobuf::int32 num_reads_;
  ::google::protobuf::int32 num_forward_reads_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Pileup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.Pileup) */ {
 public:
  Pileup();
  virtual ~Pileup();

  Pileup(const Pileup& from);

  inline Pileup& operator=(const Pileup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Pileup(Pileup&& from) noexcept
    : Pileup() {
    *this = ::std::move(from);
  }

  inline Pileup& operator=(Pileup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Pileup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pileup* internal_default_instance() {
    return reinterpret_cast<const Pileup*>(
               &_Pileup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(Pileup* other);
  friend void swap(Pileup& a, Pileup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Pileup* New() const final {
    return CreateMaybeMessage<Pileup>(NULL);
  }

  Pileup* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Pileup>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Pileup& from);
  void MergeFrom(const Pileup& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pileup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vg.NodePileup node_pileups = 1;
  int node_pileups_size() const;
  void clear_node_pileups();
  static const int kNodePileupsFieldNumber = 1;
  ::vg::NodePileup* mutable_node_pileups(int index);
  ::google::protobuf::RepeatedPtrField< ::vg::NodePileup >*
      mutable_node_pileups();
  const ::vg::NodePileup& node_pileups(int index) const;
  ::vg::NodePileup* add_node_pileups();
  const ::google::protobuf::RepeatedPtrField< ::vg::NodePileup >&
      node_pileups() const;

  // repeated .vg.EdgePileup edge_pileups = 2;
  int edge_pileups_size() const;
  void clear_edge_pileups();
  static const int kEdgePileupsFieldNumber = 2;
  ::vg::EdgePileup* mutable_edge_pileups(int index);
  ::google::protobuf::RepeatedPtrField< ::vg::EdgePileup >*
      mutable_edge_pileups();
  const ::vg::EdgePileup& edge_pileups(int index) const;
  ::vg::EdgePileup* add_edge_pileups();
  const ::google::protobuf::RepeatedPtrField< ::vg::EdgePileup >&
      edge_pileups() const;

  // @@protoc_insertion_point(class_scope:vg.Pileup)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vg::NodePileup > node_pileups_;
  ::google::protobuf::RepeatedPtrField< ::vg::EdgePileup > edge_pileups_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Snarl : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.Snarl) */ {
 public:
  Snarl();
  virtual ~Snarl();

  Snarl(const Snarl& from);

  inline Snarl& operator=(const Snarl& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Snarl(Snarl&& from) noexcept
    : Snarl() {
    *this = ::std::move(from);
  }

  inline Snarl& operator=(Snarl&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Snarl& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Snarl* internal_default_instance() {
    return reinterpret_cast<const Snarl*>(
               &_Snarl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(Snarl* other);
  friend void swap(Snarl& a, Snarl& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Snarl* New() const final {
    return CreateMaybeMessage<Snarl>(NULL);
  }

  Snarl* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Snarl>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Snarl& from);
  void MergeFrom(const Snarl& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Snarl* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 5;
  void clear_name();
  static const int kNameFieldNumber = 5;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .vg.Visit start = 2;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 2;
  private:
  const ::vg::Visit& _internal_start() const;
  public:
  const ::vg::Visit& start() const;
  ::vg::Visit* release_start();
  ::vg::Visit* mutable_start();
  void set_allocated_start(::vg::Visit* start);

  // .vg.Visit end = 3;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 3;
  private:
  const ::vg::Visit& _internal_end() const;
  public:
  const ::vg::Visit& end() const;
  ::vg::Visit* release_end();
  ::vg::Visit* mutable_end();
  void set_allocated_end(::vg::Visit* end);

  // .vg.Snarl parent = 4;
  bool has_parent() const;
  void clear_parent();
  static const int kParentFieldNumber = 4;
  private:
  const ::vg::Snarl& _internal_parent() const;
  public:
  const ::vg::Snarl& parent() const;
  ::vg::Snarl* release_parent();
  ::vg::Snarl* mutable_parent();
  void set_allocated_parent(::vg::Snarl* parent);

  // .vg.SnarlType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::vg::SnarlType type() const;
  void set_type(::vg::SnarlType value);

  // bool start_self_reachable = 6;
  void clear_start_self_reachable();
  static const int kStartSelfReachableFieldNumber = 6;
  bool start_self_reachable() const;
  void set_start_self_reachable(bool value);

  // bool end_self_reachable = 7;
  void clear_end_self_reachable();
  static const int kEndSelfReachableFieldNumber = 7;
  bool end_self_reachable() const;
  void set_end_self_reachable(bool value);

  // bool start_end_reachable = 8;
  void clear_start_end_reachable();
  static const int kStartEndReachableFieldNumber = 8;
  bool start_end_reachable() const;
  void set_start_end_reachable(bool value);

  // bool directed_acyclic_net_graph = 9;
  void clear_directed_acyclic_net_graph();
  static const int kDirectedAcyclicNetGraphFieldNumber = 9;
  bool directed_acyclic_net_graph() const;
  void set_directed_acyclic_net_graph(bool value);

  // @@protoc_insertion_point(class_scope:vg.Snarl)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::vg::Visit* start_;
  ::vg::Visit* end_;
  ::vg::Snarl* parent_;
  int type_;
  bool start_self_reachable_;
  bool end_self_reachable_;
  bool start_end_reachable_;
  bool directed_acyclic_net_graph_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Visit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.Visit) */ {
 public:
  Visit();
  virtual ~Visit();

  Visit(const Visit& from);

  inline Visit& operator=(const Visit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Visit(Visit&& from) noexcept
    : Visit() {
    *this = ::std::move(from);
  }

  inline Visit& operator=(Visit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Visit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Visit* internal_default_instance() {
    return reinterpret_cast<const Visit*>(
               &_Visit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(Visit* other);
  friend void swap(Visit& a, Visit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Visit* New() const final {
    return CreateMaybeMessage<Visit>(NULL);
  }

  Visit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Visit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Visit& from);
  void MergeFrom(const Visit& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Visit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .vg.Snarl snarl = 2;
  bool has_snarl() const;
  void clear_snarl();
  static const int kSnarlFieldNumber = 2;
  private:
  const ::vg::Snarl& _internal_snarl() const;
  public:
  const ::vg::Snarl& snarl() const;
  ::vg::Snarl* release_snarl();
  ::vg::Snarl* mutable_snarl();
  void set_allocated_snarl(::vg::Snarl* snarl);

  // int64 node_id = 1;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  ::google::protobuf::int64 node_id() const;
  void set_node_id(::google::protobuf::int64 value);

  // bool backward = 3;
  void clear_backward();
  static const int kBackwardFieldNumber = 3;
  bool backward() const;
  void set_backward(bool value);

  // @@protoc_insertion_point(class_scope:vg.Visit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::vg::Snarl* snarl_;
  ::google::protobuf::int64 node_id_;
  bool backward_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SnarlTraversal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.SnarlTraversal) */ {
 public:
  SnarlTraversal();
  virtual ~SnarlTraversal();

  SnarlTraversal(const SnarlTraversal& from);

  inline SnarlTraversal& operator=(const SnarlTraversal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SnarlTraversal(SnarlTraversal&& from) noexcept
    : SnarlTraversal() {
    *this = ::std::move(from);
  }

  inline SnarlTraversal& operator=(SnarlTraversal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SnarlTraversal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SnarlTraversal* internal_default_instance() {
    return reinterpret_cast<const SnarlTraversal*>(
               &_SnarlTraversal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(SnarlTraversal* other);
  friend void swap(SnarlTraversal& a, SnarlTraversal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SnarlTraversal* New() const final {
    return CreateMaybeMessage<SnarlTraversal>(NULL);
  }

  SnarlTraversal* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SnarlTraversal>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SnarlTraversal& from);
  void MergeFrom(const SnarlTraversal& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnarlTraversal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vg.Visit visit = 1;
  int visit_size() const;
  void clear_visit();
  static const int kVisitFieldNumber = 1;
  ::vg::Visit* mutable_visit(int index);
  ::google::protobuf::RepeatedPtrField< ::vg::Visit >*
      mutable_visit();
  const ::vg::Visit& visit(int index) const;
  ::vg::Visit* add_visit();
  const ::google::protobuf::RepeatedPtrField< ::vg::Visit >&
      visit() const;

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:vg.SnarlTraversal)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vg::Visit > visit_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Locus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.Locus) */ {
 public:
  Locus();
  virtual ~Locus();

  Locus(const Locus& from);

  inline Locus& operator=(const Locus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Locus(Locus&& from) noexcept
    : Locus() {
    *this = ::std::move(from);
  }

  inline Locus& operator=(Locus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Locus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Locus* internal_default_instance() {
    return reinterpret_cast<const Locus*>(
               &_Locus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(Locus* other);
  friend void swap(Locus& a, Locus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Locus* New() const final {
    return CreateMaybeMessage<Locus>(NULL);
  }

  Locus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Locus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Locus& from);
  void MergeFrom(const Locus& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Locus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vg.Path allele = 2;
  int allele_size() const;
  void clear_allele();
  static const int kAlleleFieldNumber = 2;
  ::vg::Path* mutable_allele(int index);
  ::google::protobuf::RepeatedPtrField< ::vg::Path >*
      mutable_allele();
  const ::vg::Path& allele(int index) const;
  ::vg::Path* add_allele();
  const ::google::protobuf::RepeatedPtrField< ::vg::Path >&
      allele() const;

  // repeated .vg.Support support = 3;
  int support_size() const;
  void clear_support();
  static const int kSupportFieldNumber = 3;
  ::vg::Support* mutable_support(int index);
  ::google::protobuf::RepeatedPtrField< ::vg::Support >*
      mutable_support();
  const ::vg::Support& support(int index) const;
  ::vg::Support* add_support();
  const ::google::protobuf::RepeatedPtrField< ::vg::Support >&
      support() const;

  // repeated .vg.Genotype genotype = 4;
  int genotype_size() const;
  void clear_genotype();
  static const int kGenotypeFieldNumber = 4;
  ::vg::Genotype* mutable_genotype(int index);
  ::google::protobuf::RepeatedPtrField< ::vg::Genotype >*
      mutable_genotype();
  const ::vg::Genotype& genotype(int index) const;
  ::vg::Genotype* add_genotype();
  const ::google::protobuf::RepeatedPtrField< ::vg::Genotype >&
      genotype() const;

  // repeated double allele_log_likelihood = 6;
  int allele_log_likelihood_size() const;
  void clear_allele_log_likelihood();
  static const int kAlleleLogLikelihoodFieldNumber = 6;
  double allele_log_likelihood(int index) const;
  void set_allele_log_likelihood(int index, double value);
  void add_allele_log_likelihood(double value);
  const ::google::protobuf::RepeatedField< double >&
      allele_log_likelihood() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_allele_log_likelihood();

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .vg.Support overall_support = 5;
  bool has_overall_support() const;
  void clear_overall_support();
  static const int kOverallSupportFieldNumber = 5;
  private:
  const ::vg::Support& _internal_overall_support() const;
  public:
  const ::vg::Support& overall_support() const;
  ::vg::Support* release_overall_support();
  ::vg::Support* mutable_overall_support();
  void set_allocated_overall_support(::vg::Support* overall_support);

  // @@protoc_insertion_point(class_scope:vg.Locus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::vg::Path > allele_;
  ::google::protobuf::RepeatedPtrField< ::vg::Support > support_;
  ::google::protobuf::RepeatedPtrField< ::vg::Genotype > genotype_;
  ::google::protobuf::RepeatedField< double > allele_log_likelihood_;
  mutable int _allele_log_likelihood_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::vg::Support* overall_support_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Genotype : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.Genotype) */ {
 public:
  Genotype();
  virtual ~Genotype();

  Genotype(const Genotype& from);

  inline Genotype& operator=(const Genotype& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Genotype(Genotype&& from) noexcept
    : Genotype() {
    *this = ::std::move(from);
  }

  inline Genotype& operator=(Genotype&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Genotype& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Genotype* internal_default_instance() {
    return reinterpret_cast<const Genotype*>(
               &_Genotype_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(Genotype* other);
  friend void swap(Genotype& a, Genotype& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Genotype* New() const final {
    return CreateMaybeMessage<Genotype>(NULL);
  }

  Genotype* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Genotype>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Genotype& from);
  void MergeFrom(const Genotype& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Genotype* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 allele = 1;
  int allele_size() const;
  void clear_allele();
  static const int kAlleleFieldNumber = 1;
  ::google::protobuf::int32 allele(int index) const;
  void set_allele(int index, ::google::protobuf::int32 value);
  void add_allele(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      allele() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_allele();

  // double likelihood = 3;
  void clear_likelihood();
  static const int kLikelihoodFieldNumber = 3;
  double likelihood() const;
  void set_likelihood(double value);

  // double log_likelihood = 4;
  void clear_log_likelihood();
  static const int kLogLikelihoodFieldNumber = 4;
  double log_likelihood() const;
  void set_log_likelihood(double value);

  // double log_prior = 5;
  void clear_log_prior();
  static const int kLogPriorFieldNumber = 5;
  double log_prior() const;
  void set_log_prior(double value);

  // double log_posterior = 6;
  void clear_log_posterior();
  static const int kLogPosteriorFieldNumber = 6;
  double log_posterior() const;
  void set_log_posterior(double value);

  // bool is_phased = 2;
  void clear_is_phased();
  static const int kIsPhasedFieldNumber = 2;
  bool is_phased() const;
  void set_is_phased(bool value);

  // @@protoc_insertion_point(class_scope:vg.Genotype)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > allele_;
  mutable int _allele_cached_byte_size_;
  double likelihood_;
  double log_likelihood_;
  double log_prior_;
  double log_posterior_;
  bool is_phased_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Support : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.Support) */ {
 public:
  Support();
  virtual ~Support();

  Support(const Support& from);

  inline Support& operator=(const Support& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Support(Support&& from) noexcept
    : Support() {
    *this = ::std::move(from);
  }

  inline Support& operator=(Support&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Support& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Support* internal_default_instance() {
    return reinterpret_cast<const Support*>(
               &_Support_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(Support* other);
  friend void swap(Support& a, Support& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Support* New() const final {
    return CreateMaybeMessage<Support>(NULL);
  }

  Support* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Support>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Support& from);
  void MergeFrom(const Support& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Support* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double quality = 1;
  void clear_quality();
  static const int kQualityFieldNumber = 1;
  double quality() const;
  void set_quality(double value);

  // double forward = 2;
  void clear_forward();
  static const int kForwardFieldNumber = 2;
  double forward() const;
  void set_forward(double value);

  // double reverse = 3;
  void clear_reverse();
  static const int kReverseFieldNumber = 3;
  double reverse() const;
  void set_reverse(double value);

  // double left = 4;
  void clear_left();
  static const int kLeftFieldNumber = 4;
  double left() const;
  void set_left(double value);

  // double right = 5;
  void clear_right();
  static const int kRightFieldNumber = 5;
  double right() const;
  void set_right(double value);

  // @@protoc_insertion_point(class_scope:vg.Support)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double quality_;
  double forward_;
  double reverse_;
  double left_;
  double right_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LocationSupport : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.LocationSupport) */ {
 public:
  LocationSupport();
  virtual ~LocationSupport();

  LocationSupport(const LocationSupport& from);

  inline LocationSupport& operator=(const LocationSupport& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LocationSupport(LocationSupport&& from) noexcept
    : LocationSupport() {
    *this = ::std::move(from);
  }

  inline LocationSupport& operator=(LocationSupport&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LocationSupport& default_instance();

  enum OneofLocationCase {
    kEdge = 2,
    kNodeId = 3,
    ONEOF_LOCATION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LocationSupport* internal_default_instance() {
    return reinterpret_cast<const LocationSupport*>(
               &_LocationSupport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(LocationSupport* other);
  friend void swap(LocationSupport& a, LocationSupport& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LocationSupport* New() const final {
    return CreateMaybeMessage<LocationSupport>(NULL);
  }

  LocationSupport* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LocationSupport>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LocationSupport& from);
  void MergeFrom(const LocationSupport& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationSupport* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .vg.Support support = 1;
  bool has_support() const;
  void clear_support();
  static const int kSupportFieldNumber = 1;
  private:
  const ::vg::Support& _internal_support() const;
  public:
  const ::vg::Support& support() const;
  ::vg::Support* release_support();
  ::vg::Support* mutable_support();
  void set_allocated_support(::vg::Support* support);

  // .vg.Edge edge = 2;
  bool has_edge() const;
  void clear_edge();
  static const int kEdgeFieldNumber = 2;
  private:
  const ::vg::Edge& _internal_edge() const;
  public:
  const ::vg::Edge& edge() const;
  ::vg::Edge* release_edge();
  ::vg::Edge* mutable_edge();
  void set_allocated_edge(::vg::Edge* edge);

  // int64 node_id = 3;
  private:
  bool has_node_id() const;
  public:
  void clear_node_id();
  static const int kNodeIdFieldNumber = 3;
  ::google::protobuf::int64 node_id() const;
  void set_node_id(::google::protobuf::int64 value);

  void clear_oneof_location();
  OneofLocationCase oneof_location_case() const;
  // @@protoc_insertion_point(class_scope:vg.LocationSupport)
 private:
  void set_has_edge();
  void set_has_node_id();

  inline bool has_oneof_location() const;
  inline void clear_has_oneof_location();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::vg::Support* support_;
  union OneofLocationUnion {
    OneofLocationUnion() {}
    ::vg::Edge* edge_;
    ::google::protobuf::int64 node_id_;
  } oneof_location_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_vg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Translation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.Translation) */ {
 public:
  Translation();
  virtual ~Translation();

  Translation(const Translation& from);

  inline Translation& operator=(const Translation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Translation(Translation&& from) noexcept
    : Translation() {
    *this = ::std::move(from);
  }

  inline Translation& operator=(Translation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Translation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Translation* internal_default_instance() {
    return reinterpret_cast<const Translation*>(
               &_Translation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(Translation* other);
  friend void swap(Translation& a, Translation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Translation* New() const final {
    return CreateMaybeMessage<Translation>(NULL);
  }

  Translation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Translation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Translation& from);
  void MergeFrom(const Translation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Translation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .vg.Path from = 1;
  bool has_from() const;
  void clear_from();
  static const int kFromFieldNumber = 1;
  private:
  const ::vg::Path& _internal_from() const;
  public:
  const ::vg::Path& from() const;
  ::vg::Path* release_from();
  ::vg::Path* mutable_from();
  void set_allocated_from(::vg::Path* from);

  // .vg.Path to = 2;
  bool has_to() const;
  void clear_to();
  static const int kToFieldNumber = 2;
  private:
  const ::vg::Path& _internal_to() const;
  public:
  const ::vg::Path& to() const;
  ::vg::Path* release_to();
  ::vg::Path* mutable_to();
  void set_allocated_to(::vg::Path* to);

  // @@protoc_insertion_point(class_scope:vg.Translation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::vg::Path* from_;
  ::vg::Path* to_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_vg_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Graph

// repeated .vg.Node node = 1;
inline int Graph::node_size() const {
  return node_.size();
}
inline void Graph::clear_node() {
  node_.Clear();
}
inline ::vg::Node* Graph::mutable_node(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Graph.node)
  return node_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Node >*
Graph::mutable_node() {
  // @@protoc_insertion_point(field_mutable_list:vg.Graph.node)
  return &node_;
}
inline const ::vg::Node& Graph::node(int index) const {
  // @@protoc_insertion_point(field_get:vg.Graph.node)
  return node_.Get(index);
}
inline ::vg::Node* Graph::add_node() {
  // @@protoc_insertion_point(field_add:vg.Graph.node)
  return node_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Node >&
Graph::node() const {
  // @@protoc_insertion_point(field_list:vg.Graph.node)
  return node_;
}

// repeated .vg.Edge edge = 2;
inline int Graph::edge_size() const {
  return edge_.size();
}
inline void Graph::clear_edge() {
  edge_.Clear();
}
inline ::vg::Edge* Graph::mutable_edge(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Graph.edge)
  return edge_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Edge >*
Graph::mutable_edge() {
  // @@protoc_insertion_point(field_mutable_list:vg.Graph.edge)
  return &edge_;
}
inline const ::vg::Edge& Graph::edge(int index) const {
  // @@protoc_insertion_point(field_get:vg.Graph.edge)
  return edge_.Get(index);
}
inline ::vg::Edge* Graph::add_edge() {
  // @@protoc_insertion_point(field_add:vg.Graph.edge)
  return edge_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Edge >&
Graph::edge() const {
  // @@protoc_insertion_point(field_list:vg.Graph.edge)
  return edge_;
}

// repeated .vg.Path path = 3;
inline int Graph::path_size() const {
  return path_.size();
}
inline void Graph::clear_path() {
  path_.Clear();
}
inline ::vg::Path* Graph::mutable_path(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Graph.path)
  return path_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Path >*
Graph::mutable_path() {
  // @@protoc_insertion_point(field_mutable_list:vg.Graph.path)
  return &path_;
}
inline const ::vg::Path& Graph::path(int index) const {
  // @@protoc_insertion_point(field_get:vg.Graph.path)
  return path_.Get(index);
}
inline ::vg::Path* Graph::add_path() {
  // @@protoc_insertion_point(field_add:vg.Graph.path)
  return path_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Path >&
Graph::path() const {
  // @@protoc_insertion_point(field_list:vg.Graph.path)
  return path_;
}

// -------------------------------------------------------------------

// Node

// string sequence = 1;
inline void Node::clear_sequence() {
  sequence_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Node::sequence() const {
  // @@protoc_insertion_point(field_get:vg.Node.sequence)
  return sequence_.GetNoArena();
}
inline void Node::set_sequence(const ::std::string& value) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Node.sequence)
}
#if LANG_CXX11
inline void Node::set_sequence(::std::string&& value) {
  
  sequence_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vg.Node.sequence)
}
#endif
inline void Node::set_sequence(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Node.sequence)
}
inline void Node::set_sequence(const char* value, size_t size) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Node.sequence)
}
inline ::std::string* Node::mutable_sequence() {
  
  // @@protoc_insertion_point(field_mutable:vg.Node.sequence)
  return sequence_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_sequence() {
  // @@protoc_insertion_point(field_release:vg.Node.sequence)
  
  return sequence_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_sequence(::std::string* sequence) {
  if (sequence != NULL) {
    
  } else {
    
  }
  sequence_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sequence);
  // @@protoc_insertion_point(field_set_allocated:vg.Node.sequence)
}

// string name = 2;
inline void Node::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Node::name() const {
  // @@protoc_insertion_point(field_get:vg.Node.name)
  return name_.GetNoArena();
}
inline void Node::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Node.name)
}
#if LANG_CXX11
inline void Node::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vg.Node.name)
}
#endif
inline void Node::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Node.name)
}
inline void Node::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Node.name)
}
inline ::std::string* Node::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:vg.Node.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_name() {
  // @@protoc_insertion_point(field_release:vg.Node.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vg.Node.name)
}

// int64 id = 3;
inline void Node::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Node::id() const {
  // @@protoc_insertion_point(field_get:vg.Node.id)
  return id_;
}
inline void Node::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:vg.Node.id)
}

// -------------------------------------------------------------------

// Edge

// int64 from = 1;
inline void Edge::clear_from() {
  from_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Edge::from() const {
  // @@protoc_insertion_point(field_get:vg.Edge.from)
  return from_;
}
inline void Edge::set_from(::google::protobuf::int64 value) {
  
  from_ = value;
  // @@protoc_insertion_point(field_set:vg.Edge.from)
}

// int64 to = 2;
inline void Edge::clear_to() {
  to_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Edge::to() const {
  // @@protoc_insertion_point(field_get:vg.Edge.to)
  return to_;
}
inline void Edge::set_to(::google::protobuf::int64 value) {
  
  to_ = value;
  // @@protoc_insertion_point(field_set:vg.Edge.to)
}

// bool from_start = 3;
inline void Edge::clear_from_start() {
  from_start_ = false;
}
inline bool Edge::from_start() const {
  // @@protoc_insertion_point(field_get:vg.Edge.from_start)
  return from_start_;
}
inline void Edge::set_from_start(bool value) {
  
  from_start_ = value;
  // @@protoc_insertion_point(field_set:vg.Edge.from_start)
}

// bool to_end = 4;
inline void Edge::clear_to_end() {
  to_end_ = false;
}
inline bool Edge::to_end() const {
  // @@protoc_insertion_point(field_get:vg.Edge.to_end)
  return to_end_;
}
inline void Edge::set_to_end(bool value) {
  
  to_end_ = value;
  // @@protoc_insertion_point(field_set:vg.Edge.to_end)
}

// int32 overlap = 5;
inline void Edge::clear_overlap() {
  overlap_ = 0;
}
inline ::google::protobuf::int32 Edge::overlap() const {
  // @@protoc_insertion_point(field_get:vg.Edge.overlap)
  return overlap_;
}
inline void Edge::set_overlap(::google::protobuf::int32 value) {
  
  overlap_ = value;
  // @@protoc_insertion_point(field_set:vg.Edge.overlap)
}

// -------------------------------------------------------------------

// Edit

// int32 from_length = 1;
inline void Edit::clear_from_length() {
  from_length_ = 0;
}
inline ::google::protobuf::int32 Edit::from_length() const {
  // @@protoc_insertion_point(field_get:vg.Edit.from_length)
  return from_length_;
}
inline void Edit::set_from_length(::google::protobuf::int32 value) {
  
  from_length_ = value;
  // @@protoc_insertion_point(field_set:vg.Edit.from_length)
}

// int32 to_length = 2;
inline void Edit::clear_to_length() {
  to_length_ = 0;
}
inline ::google::protobuf::int32 Edit::to_length() const {
  // @@protoc_insertion_point(field_get:vg.Edit.to_length)
  return to_length_;
}
inline void Edit::set_to_length(::google::protobuf::int32 value) {
  
  to_length_ = value;
  // @@protoc_insertion_point(field_set:vg.Edit.to_length)
}

// string sequence = 3;
inline void Edit::clear_sequence() {
  sequence_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Edit::sequence() const {
  // @@protoc_insertion_point(field_get:vg.Edit.sequence)
  return sequence_.GetNoArena();
}
inline void Edit::set_sequence(const ::std::string& value) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Edit.sequence)
}
#if LANG_CXX11
inline void Edit::set_sequence(::std::string&& value) {
  
  sequence_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vg.Edit.sequence)
}
#endif
inline void Edit::set_sequence(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Edit.sequence)
}
inline void Edit::set_sequence(const char* value, size_t size) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Edit.sequence)
}
inline ::std::string* Edit::mutable_sequence() {
  
  // @@protoc_insertion_point(field_mutable:vg.Edit.sequence)
  return sequence_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Edit::release_sequence() {
  // @@protoc_insertion_point(field_release:vg.Edit.sequence)
  
  return sequence_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Edit::set_allocated_sequence(::std::string* sequence) {
  if (sequence != NULL) {
    
  } else {
    
  }
  sequence_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sequence);
  // @@protoc_insertion_point(field_set_allocated:vg.Edit.sequence)
}

// -------------------------------------------------------------------

// Mapping

// .vg.Position position = 1;
inline bool Mapping::has_position() const {
  return this != internal_default_instance() && position_ != NULL;
}
inline void Mapping::clear_position() {
  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
}
inline const ::vg::Position& Mapping::_internal_position() const {
  return *position_;
}
inline const ::vg::Position& Mapping::position() const {
  const ::vg::Position* p = position_;
  // @@protoc_insertion_point(field_get:vg.Mapping.position)
  return p != NULL ? *p : *reinterpret_cast<const ::vg::Position*>(
      &::vg::_Position_default_instance_);
}
inline ::vg::Position* Mapping::release_position() {
  // @@protoc_insertion_point(field_release:vg.Mapping.position)
  
  ::vg::Position* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::vg::Position* Mapping::mutable_position() {
  
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::vg::Position>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vg.Mapping.position)
  return position_;
}
inline void Mapping::set_allocated_position(::vg::Position* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:vg.Mapping.position)
}

// repeated .vg.Edit edit = 2;
inline int Mapping::edit_size() const {
  return edit_.size();
}
inline void Mapping::clear_edit() {
  edit_.Clear();
}
inline ::vg::Edit* Mapping::mutable_edit(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Mapping.edit)
  return edit_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Edit >*
Mapping::mutable_edit() {
  // @@protoc_insertion_point(field_mutable_list:vg.Mapping.edit)
  return &edit_;
}
inline const ::vg::Edit& Mapping::edit(int index) const {
  // @@protoc_insertion_point(field_get:vg.Mapping.edit)
  return edit_.Get(index);
}
inline ::vg::Edit* Mapping::add_edit() {
  // @@protoc_insertion_point(field_add:vg.Mapping.edit)
  return edit_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Edit >&
Mapping::edit() const {
  // @@protoc_insertion_point(field_list:vg.Mapping.edit)
  return edit_;
}

// int64 rank = 5;
inline void Mapping::clear_rank() {
  rank_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Mapping::rank() const {
  // @@protoc_insertion_point(field_get:vg.Mapping.rank)
  return rank_;
}
inline void Mapping::set_rank(::google::protobuf::int64 value) {
  
  rank_ = value;
  // @@protoc_insertion_point(field_set:vg.Mapping.rank)
}

// -------------------------------------------------------------------

// Position

// int64 node_id = 1;
inline void Position::clear_node_id() {
  node_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Position::node_id() const {
  // @@protoc_insertion_point(field_get:vg.Position.node_id)
  return node_id_;
}
inline void Position::set_node_id(::google::protobuf::int64 value) {
  
  node_id_ = value;
  // @@protoc_insertion_point(field_set:vg.Position.node_id)
}

// int64 offset = 2;
inline void Position::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Position::offset() const {
  // @@protoc_insertion_point(field_get:vg.Position.offset)
  return offset_;
}
inline void Position::set_offset(::google::protobuf::int64 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:vg.Position.offset)
}

// bool is_reverse = 4;
inline void Position::clear_is_reverse() {
  is_reverse_ = false;
}
inline bool Position::is_reverse() const {
  // @@protoc_insertion_point(field_get:vg.Position.is_reverse)
  return is_reverse_;
}
inline void Position::set_is_reverse(bool value) {
  
  is_reverse_ = value;
  // @@protoc_insertion_point(field_set:vg.Position.is_reverse)
}

// string name = 5;
inline void Position::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Position::name() const {
  // @@protoc_insertion_point(field_get:vg.Position.name)
  return name_.GetNoArena();
}
inline void Position::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Position.name)
}
#if LANG_CXX11
inline void Position::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vg.Position.name)
}
#endif
inline void Position::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Position.name)
}
inline void Position::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Position.name)
}
inline ::std::string* Position::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:vg.Position.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Position::release_name() {
  // @@protoc_insertion_point(field_release:vg.Position.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Position::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vg.Position.name)
}

// -------------------------------------------------------------------

// Path

// string name = 1;
inline void Path::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Path::name() const {
  // @@protoc_insertion_point(field_get:vg.Path.name)
  return name_.GetNoArena();
}
inline void Path::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Path.name)
}
#if LANG_CXX11
inline void Path::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vg.Path.name)
}
#endif
inline void Path::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Path.name)
}
inline void Path::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Path.name)
}
inline ::std::string* Path::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:vg.Path.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Path::release_name() {
  // @@protoc_insertion_point(field_release:vg.Path.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Path::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vg.Path.name)
}

// repeated .vg.Mapping mapping = 2;
inline int Path::mapping_size() const {
  return mapping_.size();
}
inline void Path::clear_mapping() {
  mapping_.Clear();
}
inline ::vg::Mapping* Path::mutable_mapping(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Path.mapping)
  return mapping_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Mapping >*
Path::mutable_mapping() {
  // @@protoc_insertion_point(field_mutable_list:vg.Path.mapping)
  return &mapping_;
}
inline const ::vg::Mapping& Path::mapping(int index) const {
  // @@protoc_insertion_point(field_get:vg.Path.mapping)
  return mapping_.Get(index);
}
inline ::vg::Mapping* Path::add_mapping() {
  // @@protoc_insertion_point(field_add:vg.Path.mapping)
  return mapping_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Mapping >&
Path::mapping() const {
  // @@protoc_insertion_point(field_list:vg.Path.mapping)
  return mapping_;
}

// bool is_circular = 3;
inline void Path::clear_is_circular() {
  is_circular_ = false;
}
inline bool Path::is_circular() const {
  // @@protoc_insertion_point(field_get:vg.Path.is_circular)
  return is_circular_;
}
inline void Path::set_is_circular(bool value) {
  
  is_circular_ = value;
  // @@protoc_insertion_point(field_set:vg.Path.is_circular)
}

// int64 length = 4;
inline void Path::clear_length() {
  length_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Path::length() const {
  // @@protoc_insertion_point(field_get:vg.Path.length)
  return length_;
}
inline void Path::set_length(::google::protobuf::int64 value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:vg.Path.length)
}

// -------------------------------------------------------------------

// Alignment

// string sequence = 1;
inline void Alignment::clear_sequence() {
  sequence_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Alignment::sequence() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.sequence)
  return sequence_.GetNoArena();
}
inline void Alignment::set_sequence(const ::std::string& value) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Alignment.sequence)
}
#if LANG_CXX11
inline void Alignment::set_sequence(::std::string&& value) {
  
  sequence_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vg.Alignment.sequence)
}
#endif
inline void Alignment::set_sequence(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Alignment.sequence)
}
inline void Alignment::set_sequence(const char* value, size_t size) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Alignment.sequence)
}
inline ::std::string* Alignment::mutable_sequence() {
  
  // @@protoc_insertion_point(field_mutable:vg.Alignment.sequence)
  return sequence_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Alignment::release_sequence() {
  // @@protoc_insertion_point(field_release:vg.Alignment.sequence)
  
  return sequence_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Alignment::set_allocated_sequence(::std::string* sequence) {
  if (sequence != NULL) {
    
  } else {
    
  }
  sequence_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sequence);
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.sequence)
}

// .vg.Path path = 2;
inline bool Alignment::has_path() const {
  return this != internal_default_instance() && path_ != NULL;
}
inline void Alignment::clear_path() {
  if (GetArenaNoVirtual() == NULL && path_ != NULL) {
    delete path_;
  }
  path_ = NULL;
}
inline const ::vg::Path& Alignment::_internal_path() const {
  return *path_;
}
inline const ::vg::Path& Alignment::path() const {
  const ::vg::Path* p = path_;
  // @@protoc_insertion_point(field_get:vg.Alignment.path)
  return p != NULL ? *p : *reinterpret_cast<const ::vg::Path*>(
      &::vg::_Path_default_instance_);
}
inline ::vg::Path* Alignment::release_path() {
  // @@protoc_insertion_point(field_release:vg.Alignment.path)
  
  ::vg::Path* temp = path_;
  path_ = NULL;
  return temp;
}
inline ::vg::Path* Alignment::mutable_path() {
  
  if (path_ == NULL) {
    auto* p = CreateMaybeMessage<::vg::Path>(GetArenaNoVirtual());
    path_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vg.Alignment.path)
  return path_;
}
inline void Alignment::set_allocated_path(::vg::Path* path) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete path_;
  }
  if (path) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      path = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, path, submessage_arena);
    }
    
  } else {
    
  }
  path_ = path;
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.path)
}

// string name = 3;
inline void Alignment::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Alignment::name() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.name)
  return name_.GetNoArena();
}
inline void Alignment::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Alignment.name)
}
#if LANG_CXX11
inline void Alignment::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vg.Alignment.name)
}
#endif
inline void Alignment::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Alignment.name)
}
inline void Alignment::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Alignment.name)
}
inline ::std::string* Alignment::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:vg.Alignment.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Alignment::release_name() {
  // @@protoc_insertion_point(field_release:vg.Alignment.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Alignment::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.name)
}

// bytes quality = 4;
inline void Alignment::clear_quality() {
  quality_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Alignment::quality() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.quality)
  return quality_.GetNoArena();
}
inline void Alignment::set_quality(const ::std::string& value) {
  
  quality_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Alignment.quality)
}
#if LANG_CXX11
inline void Alignment::set_quality(::std::string&& value) {
  
  quality_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vg.Alignment.quality)
}
#endif
inline void Alignment::set_quality(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  quality_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Alignment.quality)
}
inline void Alignment::set_quality(const void* value, size_t size) {
  
  quality_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Alignment.quality)
}
inline ::std::string* Alignment::mutable_quality() {
  
  // @@protoc_insertion_point(field_mutable:vg.Alignment.quality)
  return quality_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Alignment::release_quality() {
  // @@protoc_insertion_point(field_release:vg.Alignment.quality)
  
  return quality_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Alignment::set_allocated_quality(::std::string* quality) {
  if (quality != NULL) {
    
  } else {
    
  }
  quality_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), quality);
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.quality)
}

// int32 mapping_quality = 5;
inline void Alignment::clear_mapping_quality() {
  mapping_quality_ = 0;
}
inline ::google::protobuf::int32 Alignment::mapping_quality() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.mapping_quality)
  return mapping_quality_;
}
inline void Alignment::set_mapping_quality(::google::protobuf::int32 value) {
  
  mapping_quality_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.mapping_quality)
}

// int32 score = 6;
inline void Alignment::clear_score() {
  score_ = 0;
}
inline ::google::protobuf::int32 Alignment::score() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.score)
  return score_;
}
inline void Alignment::set_score(::google::protobuf::int32 value) {
  
  score_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.score)
}

// int32 query_position = 7;
inline void Alignment::clear_query_position() {
  query_position_ = 0;
}
inline ::google::protobuf::int32 Alignment::query_position() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.query_position)
  return query_position_;
}
inline void Alignment::set_query_position(::google::protobuf::int32 value) {
  
  query_position_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.query_position)
}

// string sample_name = 9;
inline void Alignment::clear_sample_name() {
  sample_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Alignment::sample_name() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.sample_name)
  return sample_name_.GetNoArena();
}
inline void Alignment::set_sample_name(const ::std::string& value) {
  
  sample_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Alignment.sample_name)
}
#if LANG_CXX11
inline void Alignment::set_sample_name(::std::string&& value) {
  
  sample_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vg.Alignment.sample_name)
}
#endif
inline void Alignment::set_sample_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sample_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Alignment.sample_name)
}
inline void Alignment::set_sample_name(const char* value, size_t size) {
  
  sample_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Alignment.sample_name)
}
inline ::std::string* Alignment::mutable_sample_name() {
  
  // @@protoc_insertion_point(field_mutable:vg.Alignment.sample_name)
  return sample_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Alignment::release_sample_name() {
  // @@protoc_insertion_point(field_release:vg.Alignment.sample_name)
  
  return sample_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Alignment::set_allocated_sample_name(::std::string* sample_name) {
  if (sample_name != NULL) {
    
  } else {
    
  }
  sample_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sample_name);
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.sample_name)
}

// string read_group = 10;
inline void Alignment::clear_read_group() {
  read_group_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Alignment::read_group() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.read_group)
  return read_group_.GetNoArena();
}
inline void Alignment::set_read_group(const ::std::string& value) {
  
  read_group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Alignment.read_group)
}
#if LANG_CXX11
inline void Alignment::set_read_group(::std::string&& value) {
  
  read_group_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vg.Alignment.read_group)
}
#endif
inline void Alignment::set_read_group(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  read_group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Alignment.read_group)
}
inline void Alignment::set_read_group(const char* value, size_t size) {
  
  read_group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Alignment.read_group)
}
inline ::std::string* Alignment::mutable_read_group() {
  
  // @@protoc_insertion_point(field_mutable:vg.Alignment.read_group)
  return read_group_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Alignment::release_read_group() {
  // @@protoc_insertion_point(field_release:vg.Alignment.read_group)
  
  return read_group_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Alignment::set_allocated_read_group(::std::string* read_group) {
  if (read_group != NULL) {
    
  } else {
    
  }
  read_group_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), read_group);
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.read_group)
}

// .vg.Alignment fragment_prev = 11;
inline bool Alignment::has_fragment_prev() const {
  return this != internal_default_instance() && fragment_prev_ != NULL;
}
inline void Alignment::clear_fragment_prev() {
  if (GetArenaNoVirtual() == NULL && fragment_prev_ != NULL) {
    delete fragment_prev_;
  }
  fragment_prev_ = NULL;
}
inline const ::vg::Alignment& Alignment::_internal_fragment_prev() const {
  return *fragment_prev_;
}
inline const ::vg::Alignment& Alignment::fragment_prev() const {
  const ::vg::Alignment* p = fragment_prev_;
  // @@protoc_insertion_point(field_get:vg.Alignment.fragment_prev)
  return p != NULL ? *p : *reinterpret_cast<const ::vg::Alignment*>(
      &::vg::_Alignment_default_instance_);
}
inline ::vg::Alignment* Alignment::release_fragment_prev() {
  // @@protoc_insertion_point(field_release:vg.Alignment.fragment_prev)
  
  ::vg::Alignment* temp = fragment_prev_;
  fragment_prev_ = NULL;
  return temp;
}
inline ::vg::Alignment* Alignment::mutable_fragment_prev() {
  
  if (fragment_prev_ == NULL) {
    auto* p = CreateMaybeMessage<::vg::Alignment>(GetArenaNoVirtual());
    fragment_prev_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vg.Alignment.fragment_prev)
  return fragment_prev_;
}
inline void Alignment::set_allocated_fragment_prev(::vg::Alignment* fragment_prev) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete fragment_prev_;
  }
  if (fragment_prev) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      fragment_prev = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fragment_prev, submessage_arena);
    }
    
  } else {
    
  }
  fragment_prev_ = fragment_prev;
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.fragment_prev)
}

// .vg.Alignment fragment_next = 12;
inline bool Alignment::has_fragment_next() const {
  return this != internal_default_instance() && fragment_next_ != NULL;
}
inline void Alignment::clear_fragment_next() {
  if (GetArenaNoVirtual() == NULL && fragment_next_ != NULL) {
    delete fragment_next_;
  }
  fragment_next_ = NULL;
}
inline const ::vg::Alignment& Alignment::_internal_fragment_next() const {
  return *fragment_next_;
}
inline const ::vg::Alignment& Alignment::fragment_next() const {
  const ::vg::Alignment* p = fragment_next_;
  // @@protoc_insertion_point(field_get:vg.Alignment.fragment_next)
  return p != NULL ? *p : *reinterpret_cast<const ::vg::Alignment*>(
      &::vg::_Alignment_default_instance_);
}
inline ::vg::Alignment* Alignment::release_fragment_next() {
  // @@protoc_insertion_point(field_release:vg.Alignment.fragment_next)
  
  ::vg::Alignment* temp = fragment_next_;
  fragment_next_ = NULL;
  return temp;
}
inline ::vg::Alignment* Alignment::mutable_fragment_next() {
  
  if (fragment_next_ == NULL) {
    auto* p = CreateMaybeMessage<::vg::Alignment>(GetArenaNoVirtual());
    fragment_next_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vg.Alignment.fragment_next)
  return fragment_next_;
}
inline void Alignment::set_allocated_fragment_next(::vg::Alignment* fragment_next) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete fragment_next_;
  }
  if (fragment_next) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      fragment_next = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fragment_next, submessage_arena);
    }
    
  } else {
    
  }
  fragment_next_ = fragment_next;
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.fragment_next)
}

// bool is_secondary = 15;
inline void Alignment::clear_is_secondary() {
  is_secondary_ = false;
}
inline bool Alignment::is_secondary() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.is_secondary)
  return is_secondary_;
}
inline void Alignment::set_is_secondary(bool value) {
  
  is_secondary_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.is_secondary)
}

// double identity = 16;
inline void Alignment::clear_identity() {
  identity_ = 0;
}
inline double Alignment::identity() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.identity)
  return identity_;
}
inline void Alignment::set_identity(double value) {
  
  identity_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.identity)
}

// repeated .vg.Path fragment = 17;
inline int Alignment::fragment_size() const {
  return fragment_.size();
}
inline void Alignment::clear_fragment() {
  fragment_.Clear();
}
inline ::vg::Path* Alignment::mutable_fragment(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Alignment.fragment)
  return fragment_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Path >*
Alignment::mutable_fragment() {
  // @@protoc_insertion_point(field_mutable_list:vg.Alignment.fragment)
  return &fragment_;
}
inline const ::vg::Path& Alignment::fragment(int index) const {
  // @@protoc_insertion_point(field_get:vg.Alignment.fragment)
  return fragment_.Get(index);
}
inline ::vg::Path* Alignment::add_fragment() {
  // @@protoc_insertion_point(field_add:vg.Alignment.fragment)
  return fragment_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Path >&
Alignment::fragment() const {
  // @@protoc_insertion_point(field_list:vg.Alignment.fragment)
  return fragment_;
}

// repeated .vg.Locus locus = 18;
inline int Alignment::locus_size() const {
  return locus_.size();
}
inline void Alignment::clear_locus() {
  locus_.Clear();
}
inline ::vg::Locus* Alignment::mutable_locus(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Alignment.locus)
  return locus_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Locus >*
Alignment::mutable_locus() {
  // @@protoc_insertion_point(field_mutable_list:vg.Alignment.locus)
  return &locus_;
}
inline const ::vg::Locus& Alignment::locus(int index) const {
  // @@protoc_insertion_point(field_get:vg.Alignment.locus)
  return locus_.Get(index);
}
inline ::vg::Locus* Alignment::add_locus() {
  // @@protoc_insertion_point(field_add:vg.Alignment.locus)
  return locus_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Locus >&
Alignment::locus() const {
  // @@protoc_insertion_point(field_list:vg.Alignment.locus)
  return locus_;
}

// repeated .vg.Position refpos = 19;
inline int Alignment::refpos_size() const {
  return refpos_.size();
}
inline void Alignment::clear_refpos() {
  refpos_.Clear();
}
inline ::vg::Position* Alignment::mutable_refpos(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Alignment.refpos)
  return refpos_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Position >*
Alignment::mutable_refpos() {
  // @@protoc_insertion_point(field_mutable_list:vg.Alignment.refpos)
  return &refpos_;
}
inline const ::vg::Position& Alignment::refpos(int index) const {
  // @@protoc_insertion_point(field_get:vg.Alignment.refpos)
  return refpos_.Get(index);
}
inline ::vg::Position* Alignment::add_refpos() {
  // @@protoc_insertion_point(field_add:vg.Alignment.refpos)
  return refpos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Position >&
Alignment::refpos() const {
  // @@protoc_insertion_point(field_list:vg.Alignment.refpos)
  return refpos_;
}

// bool read_paired = 20;
inline void Alignment::clear_read_paired() {
  read_paired_ = false;
}
inline bool Alignment::read_paired() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.read_paired)
  return read_paired_;
}
inline void Alignment::set_read_paired(bool value) {
  
  read_paired_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.read_paired)
}

// bool read_mapped = 21;
inline void Alignment::clear_read_mapped() {
  read_mapped_ = false;
}
inline bool Alignment::read_mapped() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.read_mapped)
  return read_mapped_;
}
inline void Alignment::set_read_mapped(bool value) {
  
  read_mapped_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.read_mapped)
}

// bool mate_unmapped = 22;
inline void Alignment::clear_mate_unmapped() {
  mate_unmapped_ = false;
}
inline bool Alignment::mate_unmapped() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.mate_unmapped)
  return mate_unmapped_;
}
inline void Alignment::set_mate_unmapped(bool value) {
  
  mate_unmapped_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.mate_unmapped)
}

// bool read_on_reverse_strand = 23;
inline void Alignment::clear_read_on_reverse_strand() {
  read_on_reverse_strand_ = false;
}
inline bool Alignment::read_on_reverse_strand() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.read_on_reverse_strand)
  return read_on_reverse_strand_;
}
inline void Alignment::set_read_on_reverse_strand(bool value) {
  
  read_on_reverse_strand_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.read_on_reverse_strand)
}

// bool mate_on_reverse_strand = 24;
inline void Alignment::clear_mate_on_reverse_strand() {
  mate_on_reverse_strand_ = false;
}
inline bool Alignment::mate_on_reverse_strand() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.mate_on_reverse_strand)
  return mate_on_reverse_strand_;
}
inline void Alignment::set_mate_on_reverse_strand(bool value) {
  
  mate_on_reverse_strand_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.mate_on_reverse_strand)
}

// bool soft_clipped = 25;
inline void Alignment::clear_soft_clipped() {
  soft_clipped_ = false;
}
inline bool Alignment::soft_clipped() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.soft_clipped)
  return soft_clipped_;
}
inline void Alignment::set_soft_clipped(bool value) {
  
  soft_clipped_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.soft_clipped)
}

// bool discordant_insert_size = 26;
inline void Alignment::clear_discordant_insert_size() {
  discordant_insert_size_ = false;
}
inline bool Alignment::discordant_insert_size() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.discordant_insert_size)
  return discordant_insert_size_;
}
inline void Alignment::set_discordant_insert_size(bool value) {
  
  discordant_insert_size_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.discordant_insert_size)
}

// double uniqueness = 27;
inline void Alignment::clear_uniqueness() {
  uniqueness_ = 0;
}
inline double Alignment::uniqueness() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.uniqueness)
  return uniqueness_;
}
inline void Alignment::set_uniqueness(double value) {
  
  uniqueness_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.uniqueness)
}

// double correct = 28;
inline void Alignment::clear_correct() {
  correct_ = 0;
}
inline double Alignment::correct() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.correct)
  return correct_;
}
inline void Alignment::set_correct(double value) {
  
  correct_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.correct)
}

// repeated int32 secondary_score = 29;
inline int Alignment::secondary_score_size() const {
  return secondary_score_.size();
}
inline void Alignment::clear_secondary_score() {
  secondary_score_.Clear();
}
inline ::google::protobuf::int32 Alignment::secondary_score(int index) const {
  // @@protoc_insertion_point(field_get:vg.Alignment.secondary_score)
  return secondary_score_.Get(index);
}
inline void Alignment::set_secondary_score(int index, ::google::protobuf::int32 value) {
  secondary_score_.Set(index, value);
  // @@protoc_insertion_point(field_set:vg.Alignment.secondary_score)
}
inline void Alignment::add_secondary_score(::google::protobuf::int32 value) {
  secondary_score_.Add(value);
  // @@protoc_insertion_point(field_add:vg.Alignment.secondary_score)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Alignment::secondary_score() const {
  // @@protoc_insertion_point(field_list:vg.Alignment.secondary_score)
  return secondary_score_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Alignment::mutable_secondary_score() {
  // @@protoc_insertion_point(field_mutable_list:vg.Alignment.secondary_score)
  return &secondary_score_;
}

// double fragment_score = 30;
inline void Alignment::clear_fragment_score() {
  fragment_score_ = 0;
}
inline double Alignment::fragment_score() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.fragment_score)
  return fragment_score_;
}
inline void Alignment::set_fragment_score(double value) {
  
  fragment_score_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.fragment_score)
}

// bool mate_mapped_to_disjoint_subgraph = 31;
inline void Alignment::clear_mate_mapped_to_disjoint_subgraph() {
  mate_mapped_to_disjoint_subgraph_ = false;
}
inline bool Alignment::mate_mapped_to_disjoint_subgraph() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.mate_mapped_to_disjoint_subgraph)
  return mate_mapped_to_disjoint_subgraph_;
}
inline void Alignment::set_mate_mapped_to_disjoint_subgraph(bool value) {
  
  mate_mapped_to_disjoint_subgraph_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.mate_mapped_to_disjoint_subgraph)
}

// string fragment_length_distribution = 32;
inline void Alignment::clear_fragment_length_distribution() {
  fragment_length_distribution_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Alignment::fragment_length_distribution() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.fragment_length_distribution)
  return fragment_length_distribution_.GetNoArena();
}
inline void Alignment::set_fragment_length_distribution(const ::std::string& value) {
  
  fragment_length_distribution_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Alignment.fragment_length_distribution)
}
#if LANG_CXX11
inline void Alignment::set_fragment_length_distribution(::std::string&& value) {
  
  fragment_length_distribution_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vg.Alignment.fragment_length_distribution)
}
#endif
inline void Alignment::set_fragment_length_distribution(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  fragment_length_distribution_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Alignment.fragment_length_distribution)
}
inline void Alignment::set_fragment_length_distribution(const char* value, size_t size) {
  
  fragment_length_distribution_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Alignment.fragment_length_distribution)
}
inline ::std::string* Alignment::mutable_fragment_length_distribution() {
  
  // @@protoc_insertion_point(field_mutable:vg.Alignment.fragment_length_distribution)
  return fragment_length_distribution_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Alignment::release_fragment_length_distribution() {
  // @@protoc_insertion_point(field_release:vg.Alignment.fragment_length_distribution)
  
  return fragment_length_distribution_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Alignment::set_allocated_fragment_length_distribution(::std::string* fragment_length_distribution) {
  if (fragment_length_distribution != NULL) {
    
  } else {
    
  }
  fragment_length_distribution_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fragment_length_distribution);
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.fragment_length_distribution)
}

// bool haplotype_scored = 33;
inline void Alignment::clear_haplotype_scored() {
  haplotype_scored_ = false;
}
inline bool Alignment::haplotype_scored() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.haplotype_scored)
  return haplotype_scored_;
}
inline void Alignment::set_haplotype_scored(bool value) {
  
  haplotype_scored_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.haplotype_scored)
}

// double haplotype_logprob = 34;
inline void Alignment::clear_haplotype_logprob() {
  haplotype_logprob_ = 0;
}
inline double Alignment::haplotype_logprob() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.haplotype_logprob)
  return haplotype_logprob_;
}
inline void Alignment::set_haplotype_logprob(double value) {
  
  haplotype_logprob_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.haplotype_logprob)
}

// double time_used = 35;
inline void Alignment::clear_time_used() {
  time_used_ = 0;
}
inline double Alignment::time_used() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.time_used)
  return time_used_;
}
inline void Alignment::set_time_used(double value) {
  
  time_used_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.time_used)
}

// .vg.Position to_correct = 36;
inline bool Alignment::has_to_correct() const {
  return this != internal_default_instance() && to_correct_ != NULL;
}
inline void Alignment::clear_to_correct() {
  if (GetArenaNoVirtual() == NULL && to_correct_ != NULL) {
    delete to_correct_;
  }
  to_correct_ = NULL;
}
inline const ::vg::Position& Alignment::_internal_to_correct() const {
  return *to_correct_;
}
inline const ::vg::Position& Alignment::to_correct() const {
  const ::vg::Position* p = to_correct_;
  // @@protoc_insertion_point(field_get:vg.Alignment.to_correct)
  return p != NULL ? *p : *reinterpret_cast<const ::vg::Position*>(
      &::vg::_Position_default_instance_);
}
inline ::vg::Position* Alignment::release_to_correct() {
  // @@protoc_insertion_point(field_release:vg.Alignment.to_correct)
  
  ::vg::Position* temp = to_correct_;
  to_correct_ = NULL;
  return temp;
}
inline ::vg::Position* Alignment::mutable_to_correct() {
  
  if (to_correct_ == NULL) {
    auto* p = CreateMaybeMessage<::vg::Position>(GetArenaNoVirtual());
    to_correct_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vg.Alignment.to_correct)
  return to_correct_;
}
inline void Alignment::set_allocated_to_correct(::vg::Position* to_correct) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete to_correct_;
  }
  if (to_correct) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      to_correct = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, to_correct, submessage_arena);
    }
    
  } else {
    
  }
  to_correct_ = to_correct;
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.to_correct)
}

// bool correctly_mapped = 37;
inline void Alignment::clear_correctly_mapped() {
  correctly_mapped_ = false;
}
inline bool Alignment::correctly_mapped() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.correctly_mapped)
  return correctly_mapped_;
}
inline void Alignment::set_correctly_mapped(bool value) {
  
  correctly_mapped_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.correctly_mapped)
}

// .google.protobuf.Struct annotation = 100;
inline bool Alignment::has_annotation() const {
  return this != internal_default_instance() && annotation_ != NULL;
}
inline const ::google::protobuf::Struct& Alignment::_internal_annotation() const {
  return *annotation_;
}
inline const ::google::protobuf::Struct& Alignment::annotation() const {
  const ::google::protobuf::Struct* p = annotation_;
  // @@protoc_insertion_point(field_get:vg.Alignment.annotation)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Struct*>(
      &::google::protobuf::_Struct_default_instance_);
}
inline ::google::protobuf::Struct* Alignment::release_annotation() {
  // @@protoc_insertion_point(field_release:vg.Alignment.annotation)
  
  ::google::protobuf::Struct* temp = annotation_;
  annotation_ = NULL;
  return temp;
}
inline ::google::protobuf::Struct* Alignment::mutable_annotation() {
  
  if (annotation_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Struct>(GetArenaNoVirtual());
    annotation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vg.Alignment.annotation)
  return annotation_;
}
inline void Alignment::set_allocated_annotation(::google::protobuf::Struct* annotation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(annotation_);
  }
  if (annotation) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(annotation)->GetArena();
    if (message_arena != submessage_arena) {
      annotation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, annotation, submessage_arena);
    }
    
  } else {
    
  }
  annotation_ = annotation;
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.annotation)
}

// -------------------------------------------------------------------

// MultipathAlignment

// string sequence = 1;
inline void MultipathAlignment::clear_sequence() {
  sequence_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MultipathAlignment::sequence() const {
  // @@protoc_insertion_point(field_get:vg.MultipathAlignment.sequence)
  return sequence_.GetNoArena();
}
inline void MultipathAlignment::set_sequence(const ::std::string& value) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.MultipathAlignment.sequence)
}
#if LANG_CXX11
inline void MultipathAlignment::set_sequence(::std::string&& value) {
  
  sequence_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vg.MultipathAlignment.sequence)
}
#endif
inline void MultipathAlignment::set_sequence(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.MultipathAlignment.sequence)
}
inline void MultipathAlignment::set_sequence(const char* value, size_t size) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.MultipathAlignment.sequence)
}
inline ::std::string* MultipathAlignment::mutable_sequence() {
  
  // @@protoc_insertion_point(field_mutable:vg.MultipathAlignment.sequence)
  return sequence_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MultipathAlignment::release_sequence() {
  // @@protoc_insertion_point(field_release:vg.MultipathAlignment.sequence)
  
  return sequence_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MultipathAlignment::set_allocated_sequence(::std::string* sequence) {
  if (sequence != NULL) {
    
  } else {
    
  }
  sequence_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sequence);
  // @@protoc_insertion_point(field_set_allocated:vg.MultipathAlignment.sequence)
}

// bytes quality = 2;
inline void MultipathAlignment::clear_quality() {
  quality_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MultipathAlignment::quality() const {
  // @@protoc_insertion_point(field_get:vg.MultipathAlignment.quality)
  return quality_.GetNoArena();
}
inline void MultipathAlignment::set_quality(const ::std::string& value) {
  
  quality_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.MultipathAlignment.quality)
}
#if LANG_CXX11
inline void MultipathAlignment::set_quality(::std::string&& value) {
  
  quality_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vg.MultipathAlignment.quality)
}
#endif
inline void MultipathAlignment::set_quality(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  quality_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.MultipathAlignment.quality)
}
inline void MultipathAlignment::set_quality(const void* value, size_t size) {
  
  quality_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.MultipathAlignment.quality)
}
inline ::std::string* MultipathAlignment::mutable_quality() {
  
  // @@protoc_insertion_point(field_mutable:vg.MultipathAlignment.quality)
  return quality_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MultipathAlignment::release_quality() {
  // @@protoc_insertion_point(field_release:vg.MultipathAlignment.quality)
  
  return quality_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MultipathAlignment::set_allocated_quality(::std::string* quality) {
  if (quality != NULL) {
    
  } else {
    
  }
  quality_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), quality);
  // @@protoc_insertion_point(field_set_allocated:vg.MultipathAlignment.quality)
}

// string name = 3;
inline void MultipathAlignment::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MultipathAlignment::name() const {
  // @@protoc_insertion_point(field_get:vg.MultipathAlignment.name)
  return name_.GetNoArena();
}
inline void MultipathAlignment::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.MultipathAlignment.name)
}
#if LANG_CXX11
inline void MultipathAlignment::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vg.MultipathAlignment.name)
}
#endif
inline void MultipathAlignment::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.MultipathAlignment.name)
}
inline void MultipathAlignment::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.MultipathAlignment.name)
}
inline ::std::string* MultipathAlignment::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:vg.MultipathAlignment.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MultipathAlignment::release_name() {
  // @@protoc_insertion_point(field_release:vg.MultipathAlignment.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MultipathAlignment::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vg.MultipathAlignment.name)
}

// string sample_name = 4;
inline void MultipathAlignment::clear_sample_name() {
  sample_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MultipathAlignment::sample_name() const {
  // @@protoc_insertion_point(field_get:vg.MultipathAlignment.sample_name)
  return sample_name_.GetNoArena();
}
inline void MultipathAlignment::set_sample_name(const ::std::string& value) {
  
  sample_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.MultipathAlignment.sample_name)
}
#if LANG_CXX11
inline void MultipathAlignment::set_sample_name(::std::string&& value) {
  
  sample_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vg.MultipathAlignment.sample_name)
}
#endif
inline void MultipathAlignment::set_sample_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sample_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.MultipathAlignment.sample_name)
}
inline void MultipathAlignment::set_sample_name(const char* value, size_t size) {
  
  sample_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.MultipathAlignment.sample_name)
}
inline ::std::string* MultipathAlignment::mutable_sample_name() {
  
  // @@protoc_insertion_point(field_mutable:vg.MultipathAlignment.sample_name)
  return sample_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MultipathAlignment::release_sample_name() {
  // @@protoc_insertion_point(field_release:vg.MultipathAlignment.sample_name)
  
  return sample_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MultipathAlignment::set_allocated_sample_name(::std::string* sample_name) {
  if (sample_name != NULL) {
    
  } else {
    
  }
  sample_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sample_name);
  // @@protoc_insertion_point(field_set_allocated:vg.MultipathAlignment.sample_name)
}

// string read_group = 5;
inline void MultipathAlignment::clear_read_group() {
  read_group_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MultipathAlignment::read_group() const {
  // @@protoc_insertion_point(field_get:vg.MultipathAlignment.read_group)
  return read_group_.GetNoArena();
}
inline void MultipathAlignment::set_read_group(const ::std::string& value) {
  
  read_group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.MultipathAlignment.read_group)
}
#if LANG_CXX11
inline void MultipathAlignment::set_read_group(::std::string&& value) {
  
  read_group_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vg.MultipathAlignment.read_group)
}
#endif
inline void MultipathAlignment::set_read_group(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  read_group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.MultipathAlignment.read_group)
}
inline void MultipathAlignment::set_read_group(const char* value, size_t size) {
  
  read_group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.MultipathAlignment.read_group)
}
inline ::std::string* MultipathAlignment::mutable_read_group() {
  
  // @@protoc_insertion_point(field_mutable:vg.MultipathAlignment.read_group)
  return read_group_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MultipathAlignment::release_read_group() {
  // @@protoc_insertion_point(field_release:vg.MultipathAlignment.read_group)
  
  return read_group_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MultipathAlignment::set_allocated_read_group(::std::string* read_group) {
  if (read_group != NULL) {
    
  } else {
    
  }
  read_group_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), read_group);
  // @@protoc_insertion_point(field_set_allocated:vg.MultipathAlignment.read_group)
}

// repeated .vg.Subpath subpath = 6;
inline int MultipathAlignment::subpath_size() const {
  return subpath_.size();
}
inline void MultipathAlignment::clear_subpath() {
  subpath_.Clear();
}
inline ::vg::Subpath* MultipathAlignment::mutable_subpath(int index) {
  // @@protoc_insertion_point(field_mutable:vg.MultipathAlignment.subpath)
  return subpath_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Subpath >*
MultipathAlignment::mutable_subpath() {
  // @@protoc_insertion_point(field_mutable_list:vg.MultipathAlignment.subpath)
  return &subpath_;
}
inline const ::vg::Subpath& MultipathAlignment::subpath(int index) const {
  // @@protoc_insertion_point(field_get:vg.MultipathAlignment.subpath)
  return subpath_.Get(index);
}
inline ::vg::Subpath* MultipathAlignment::add_subpath() {
  // @@protoc_insertion_point(field_add:vg.MultipathAlignment.subpath)
  return subpath_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Subpath >&
MultipathAlignment::subpath() const {
  // @@protoc_insertion_point(field_list:vg.MultipathAlignment.subpath)
  return subpath_;
}

// int32 mapping_quality = 7;
inline void MultipathAlignment::clear_mapping_quality() {
  mapping_quality_ = 0;
}
inline ::google::protobuf::int32 MultipathAlignment::mapping_quality() const {
  // @@protoc_insertion_point(field_get:vg.MultipathAlignment.mapping_quality)
  return mapping_quality_;
}
inline void MultipathAlignment::set_mapping_quality(::google::protobuf::int32 value) {
  
  mapping_quality_ = value;
  // @@protoc_insertion_point(field_set:vg.MultipathAlignment.mapping_quality)
}

// repeated uint32 start = 8;
inline int MultipathAlignment::start_size() const {
  return start_.size();
}
inline void MultipathAlignment::clear_start() {
  start_.Clear();
}
inline ::google::protobuf::uint32 MultipathAlignment::start(int index) const {
  // @@protoc_insertion_point(field_get:vg.MultipathAlignment.start)
  return start_.Get(index);
}
inline void MultipathAlignment::set_start(int index, ::google::protobuf::uint32 value) {
  start_.Set(index, value);
  // @@protoc_insertion_point(field_set:vg.MultipathAlignment.start)
}
inline void MultipathAlignment::add_start(::google::protobuf::uint32 value) {
  start_.Add(value);
  // @@protoc_insertion_point(field_add:vg.MultipathAlignment.start)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MultipathAlignment::start() const {
  // @@protoc_insertion_point(field_list:vg.MultipathAlignment.start)
  return start_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MultipathAlignment::mutable_start() {
  // @@protoc_insertion_point(field_mutable_list:vg.MultipathAlignment.start)
  return &start_;
}

// string paired_read_name = 9;
inline void MultipathAlignment::clear_paired_read_name() {
  paired_read_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MultipathAlignment::paired_read_name() const {
  // @@protoc_insertion_point(field_get:vg.MultipathAlignment.paired_read_name)
  return paired_read_name_.GetNoArena();
}
inline void MultipathAlignment::set_paired_read_name(const ::std::string& value) {
  
  paired_read_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.MultipathAlignment.paired_read_name)
}
#if LANG_CXX11
inline void MultipathAlignment::set_paired_read_name(::std::string&& value) {
  
  paired_read_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vg.MultipathAlignment.paired_read_name)
}
#endif
inline void MultipathAlignment::set_paired_read_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  paired_read_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.MultipathAlignment.paired_read_name)
}
inline void MultipathAlignment::set_paired_read_name(const char* value, size_t size) {
  
  paired_read_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.MultipathAlignment.paired_read_name)
}
inline ::std::string* MultipathAlignment::mutable_paired_read_name() {
  
  // @@protoc_insertion_point(field_mutable:vg.MultipathAlignment.paired_read_name)
  return paired_read_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MultipathAlignment::release_paired_read_name() {
  // @@protoc_insertion_point(field_release:vg.MultipathAlignment.paired_read_name)
  
  return paired_read_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MultipathAlignment::set_allocated_paired_read_name(::std::string* paired_read_name) {
  if (paired_read_name != NULL) {
    
  } else {
    
  }
  paired_read_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), paired_read_name);
  // @@protoc_insertion_point(field_set_allocated:vg.MultipathAlignment.paired_read_name)
}

// .google.protobuf.Struct annotation = 100;
inline bool MultipathAlignment::has_annotation() const {
  return this != internal_default_instance() && annotation_ != NULL;
}
inline const ::google::protobuf::Struct& MultipathAlignment::_internal_annotation() const {
  return *annotation_;
}
inline const ::google::protobuf::Struct& MultipathAlignment::annotation() const {
  const ::google::protobuf::Struct* p = annotation_;
  // @@protoc_insertion_point(field_get:vg.MultipathAlignment.annotation)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Struct*>(
      &::google::protobuf::_Struct_default_instance_);
}
inline ::google::protobuf::Struct* MultipathAlignment::release_annotation() {
  // @@protoc_insertion_point(field_release:vg.MultipathAlignment.annotation)
  
  ::google::protobuf::Struct* temp = annotation_;
  annotation_ = NULL;
  return temp;
}
inline ::google::protobuf::Struct* MultipathAlignment::mutable_annotation() {
  
  if (annotation_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Struct>(GetArenaNoVirtual());
    annotation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vg.MultipathAlignment.annotation)
  return annotation_;
}
inline void MultipathAlignment::set_allocated_annotation(::google::protobuf::Struct* annotation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(annotation_);
  }
  if (annotation) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(annotation)->GetArena();
    if (message_arena != submessage_arena) {
      annotation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, annotation, submessage_arena);
    }
    
  } else {
    
  }
  annotation_ = annotation;
  // @@protoc_insertion_point(field_set_allocated:vg.MultipathAlignment.annotation)
}

// -------------------------------------------------------------------

// Subpath

// .vg.Path path = 1;
inline bool Subpath::has_path() const {
  return this != internal_default_instance() && path_ != NULL;
}
inline void Subpath::clear_path() {
  if (GetArenaNoVirtual() == NULL && path_ != NULL) {
    delete path_;
  }
  path_ = NULL;
}
inline const ::vg::Path& Subpath::_internal_path() const {
  return *path_;
}
inline const ::vg::Path& Subpath::path() const {
  const ::vg::Path* p = path_;
  // @@protoc_insertion_point(field_get:vg.Subpath.path)
  return p != NULL ? *p : *reinterpret_cast<const ::vg::Path*>(
      &::vg::_Path_default_instance_);
}
inline ::vg::Path* Subpath::release_path() {
  // @@protoc_insertion_point(field_release:vg.Subpath.path)
  
  ::vg::Path* temp = path_;
  path_ = NULL;
  return temp;
}
inline ::vg::Path* Subpath::mutable_path() {
  
  if (path_ == NULL) {
    auto* p = CreateMaybeMessage<::vg::Path>(GetArenaNoVirtual());
    path_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vg.Subpath.path)
  return path_;
}
inline void Subpath::set_allocated_path(::vg::Path* path) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete path_;
  }
  if (path) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      path = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, path, submessage_arena);
    }
    
  } else {
    
  }
  path_ = path;
  // @@protoc_insertion_point(field_set_allocated:vg.Subpath.path)
}

// repeated uint32 next = 2;
inline int Subpath::next_size() const {
  return next_.size();
}
inline void Subpath::clear_next() {
  next_.Clear();
}
inline ::google::protobuf::uint32 Subpath::next(int index) const {
  // @@protoc_insertion_point(field_get:vg.Subpath.next)
  return next_.Get(index);
}
inline void Subpath::set_next(int index, ::google::protobuf::uint32 value) {
  next_.Set(index, value);
  // @@protoc_insertion_point(field_set:vg.Subpath.next)
}
inline void Subpath::add_next(::google::protobuf::uint32 value) {
  next_.Add(value);
  // @@protoc_insertion_point(field_add:vg.Subpath.next)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Subpath::next() const {
  // @@protoc_insertion_point(field_list:vg.Subpath.next)
  return next_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Subpath::mutable_next() {
  // @@protoc_insertion_point(field_mutable_list:vg.Subpath.next)
  return &next_;
}

// int32 score = 3;
inline void Subpath::clear_score() {
  score_ = 0;
}
inline ::google::protobuf::int32 Subpath::score() const {
  // @@protoc_insertion_point(field_get:vg.Subpath.score)
  return score_;
}
inline void Subpath::set_score(::google::protobuf::int32 value) {
  
  score_ = value;
  // @@protoc_insertion_point(field_set:vg.Subpath.score)
}

// -------------------------------------------------------------------

// KmerMatch

// string sequence = 1;
inline void KmerMatch::clear_sequence() {
  sequence_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KmerMatch::sequence() const {
  // @@protoc_insertion_point(field_get:vg.KmerMatch.sequence)
  return sequence_.GetNoArena();
}
inline void KmerMatch::set_sequence(const ::std::string& value) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.KmerMatch.sequence)
}
#if LANG_CXX11
inline void KmerMatch::set_sequence(::std::string&& value) {
  
  sequence_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vg.KmerMatch.sequence)
}
#endif
inline void KmerMatch::set_sequence(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.KmerMatch.sequence)
}
inline void KmerMatch::set_sequence(const char* value, size_t size) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.KmerMatch.sequence)
}
inline ::std::string* KmerMatch::mutable_sequence() {
  
  // @@protoc_insertion_point(field_mutable:vg.KmerMatch.sequence)
  return sequence_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KmerMatch::release_sequence() {
  // @@protoc_insertion_point(field_release:vg.KmerMatch.sequence)
  
  return sequence_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KmerMatch::set_allocated_sequence(::std::string* sequence) {
  if (sequence != NULL) {
    
  } else {
    
  }
  sequence_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sequence);
  // @@protoc_insertion_point(field_set_allocated:vg.KmerMatch.sequence)
}

// int64 node_id = 2;
inline void KmerMatch::clear_node_id() {
  node_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 KmerMatch::node_id() const {
  // @@protoc_insertion_point(field_get:vg.KmerMatch.node_id)
  return node_id_;
}
inline void KmerMatch::set_node_id(::google::protobuf::int64 value) {
  
  node_id_ = value;
  // @@protoc_insertion_point(field_set:vg.KmerMatch.node_id)
}

// sint32 position = 3;
inline void KmerMatch::clear_position() {
  position_ = 0;
}
inline ::google::protobuf::int32 KmerMatch::position() const {
  // @@protoc_insertion_point(field_get:vg.KmerMatch.position)
  return position_;
}
inline void KmerMatch::set_position(::google::protobuf::int32 value) {
  
  position_ = value;
  // @@protoc_insertion_point(field_set:vg.KmerMatch.position)
}

// bool backward = 4;
inline void KmerMatch::clear_backward() {
  backward_ = false;
}
inline bool KmerMatch::backward() const {
  // @@protoc_insertion_point(field_get:vg.KmerMatch.backward)
  return backward_;
}
inline void KmerMatch::set_backward(bool value) {
  
  backward_ = value;
  // @@protoc_insertion_point(field_set:vg.KmerMatch.backward)
}

// -------------------------------------------------------------------

// BasePileup

// int32 ref_base = 1;
inline void BasePileup::clear_ref_base() {
  ref_base_ = 0;
}
inline ::google::protobuf::int32 BasePileup::ref_base() const {
  // @@protoc_insertion_point(field_get:vg.BasePileup.ref_base)
  return ref_base_;
}
inline void BasePileup::set_ref_base(::google::protobuf::int32 value) {
  
  ref_base_ = value;
  // @@protoc_insertion_point(field_set:vg.BasePileup.ref_base)
}

// int32 num_bases = 2;
inline void BasePileup::clear_num_bases() {
  num_bases_ = 0;
}
inline ::google::protobuf::int32 BasePileup::num_bases() const {
  // @@protoc_insertion_point(field_get:vg.BasePileup.num_bases)
  return num_bases_;
}
inline void BasePileup::set_num_bases(::google::protobuf::int32 value) {
  
  num_bases_ = value;
  // @@protoc_insertion_point(field_set:vg.BasePileup.num_bases)
}

// string bases = 3;
inline void BasePileup::clear_bases() {
  bases_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BasePileup::bases() const {
  // @@protoc_insertion_point(field_get:vg.BasePileup.bases)
  return bases_.GetNoArena();
}
inline void BasePileup::set_bases(const ::std::string& value) {
  
  bases_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.BasePileup.bases)
}
#if LANG_CXX11
inline void BasePileup::set_bases(::std::string&& value) {
  
  bases_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vg.BasePileup.bases)
}
#endif
inline void BasePileup::set_bases(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bases_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.BasePileup.bases)
}
inline void BasePileup::set_bases(const char* value, size_t size) {
  
  bases_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.BasePileup.bases)
}
inline ::std::string* BasePileup::mutable_bases() {
  
  // @@protoc_insertion_point(field_mutable:vg.BasePileup.bases)
  return bases_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BasePileup::release_bases() {
  // @@protoc_insertion_point(field_release:vg.BasePileup.bases)
  
  return bases_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BasePileup::set_allocated_bases(::std::string* bases) {
  if (bases != NULL) {
    
  } else {
    
  }
  bases_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bases);
  // @@protoc_insertion_point(field_set_allocated:vg.BasePileup.bases)
}

// bytes qualities = 4;
inline void BasePileup::clear_qualities() {
  qualities_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BasePileup::qualities() const {
  // @@protoc_insertion_point(field_get:vg.BasePileup.qualities)
  return qualities_.GetNoArena();
}
inline void BasePileup::set_qualities(const ::std::string& value) {
  
  qualities_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.BasePileup.qualities)
}
#if LANG_CXX11
inline void BasePileup::set_qualities(::std::string&& value) {
  
  qualities_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vg.BasePileup.qualities)
}
#endif
inline void BasePileup::set_qualities(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  qualities_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.BasePileup.qualities)
}
inline void BasePileup::set_qualities(const void* value, size_t size) {
  
  qualities_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.BasePileup.qualities)
}
inline ::std::string* BasePileup::mutable_qualities() {
  
  // @@protoc_insertion_point(field_mutable:vg.BasePileup.qualities)
  return qualities_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BasePileup::release_qualities() {
  // @@protoc_insertion_point(field_release:vg.BasePileup.qualities)
  
  return qualities_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BasePileup::set_allocated_qualities(::std::string* qualities) {
  if (qualities != NULL) {
    
  } else {
    
  }
  qualities_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), qualities);
  // @@protoc_insertion_point(field_set_allocated:vg.BasePileup.qualities)
}

// -------------------------------------------------------------------

// NodePileup

// int64 node_id = 1;
inline void NodePileup::clear_node_id() {
  node_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 NodePileup::node_id() const {
  // @@protoc_insertion_point(field_get:vg.NodePileup.node_id)
  return node_id_;
}
inline void NodePileup::set_node_id(::google::protobuf::int64 value) {
  
  node_id_ = value;
  // @@protoc_insertion_point(field_set:vg.NodePileup.node_id)
}

// repeated .vg.BasePileup base_pileup = 2;
inline int NodePileup::base_pileup_size() const {
  return base_pileup_.size();
}
inline void NodePileup::clear_base_pileup() {
  base_pileup_.Clear();
}
inline ::vg::BasePileup* NodePileup::mutable_base_pileup(int index) {
  // @@protoc_insertion_point(field_mutable:vg.NodePileup.base_pileup)
  return base_pileup_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vg::BasePileup >*
NodePileup::mutable_base_pileup() {
  // @@protoc_insertion_point(field_mutable_list:vg.NodePileup.base_pileup)
  return &base_pileup_;
}
inline const ::vg::BasePileup& NodePileup::base_pileup(int index) const {
  // @@protoc_insertion_point(field_get:vg.NodePileup.base_pileup)
  return base_pileup_.Get(index);
}
inline ::vg::BasePileup* NodePileup::add_base_pileup() {
  // @@protoc_insertion_point(field_add:vg.NodePileup.base_pileup)
  return base_pileup_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::BasePileup >&
NodePileup::base_pileup() const {
  // @@protoc_insertion_point(field_list:vg.NodePileup.base_pileup)
  return base_pileup_;
}

// -------------------------------------------------------------------

// EdgePileup

// .vg.Edge edge = 1;
inline bool EdgePileup::has_edge() const {
  return this != internal_default_instance() && edge_ != NULL;
}
inline void EdgePileup::clear_edge() {
  if (GetArenaNoVirtual() == NULL && edge_ != NULL) {
    delete edge_;
  }
  edge_ = NULL;
}
inline const ::vg::Edge& EdgePileup::_internal_edge() const {
  return *edge_;
}
inline const ::vg::Edge& EdgePileup::edge() const {
  const ::vg::Edge* p = edge_;
  // @@protoc_insertion_point(field_get:vg.EdgePileup.edge)
  return p != NULL ? *p : *reinterpret_cast<const ::vg::Edge*>(
      &::vg::_Edge_default_instance_);
}
inline ::vg::Edge* EdgePileup::release_edge() {
  // @@protoc_insertion_point(field_release:vg.EdgePileup.edge)
  
  ::vg::Edge* temp = edge_;
  edge_ = NULL;
  return temp;
}
inline ::vg::Edge* EdgePileup::mutable_edge() {
  
  if (edge_ == NULL) {
    auto* p = CreateMaybeMessage<::vg::Edge>(GetArenaNoVirtual());
    edge_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vg.EdgePileup.edge)
  return edge_;
}
inline void EdgePileup::set_allocated_edge(::vg::Edge* edge) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete edge_;
  }
  if (edge) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      edge = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, edge, submessage_arena);
    }
    
  } else {
    
  }
  edge_ = edge;
  // @@protoc_insertion_point(field_set_allocated:vg.EdgePileup.edge)
}

// int32 num_reads = 2;
inline void EdgePileup::clear_num_reads() {
  num_reads_ = 0;
}
inline ::google::protobuf::int32 EdgePileup::num_reads() const {
  // @@protoc_insertion_point(field_get:vg.EdgePileup.num_reads)
  return num_reads_;
}
inline void EdgePileup::set_num_reads(::google::protobuf::int32 value) {
  
  num_reads_ = value;
  // @@protoc_insertion_point(field_set:vg.EdgePileup.num_reads)
}

// int32 num_forward_reads = 3;
inline void EdgePileup::clear_num_forward_reads() {
  num_forward_reads_ = 0;
}
inline ::google::protobuf::int32 EdgePileup::num_forward_reads() const {
  // @@protoc_insertion_point(field_get:vg.EdgePileup.num_forward_reads)
  return num_forward_reads_;
}
inline void EdgePileup::set_num_forward_reads(::google::protobuf::int32 value) {
  
  num_forward_reads_ = value;
  // @@protoc_insertion_point(field_set:vg.EdgePileup.num_forward_reads)
}

// bytes qualities = 4;
inline void EdgePileup::clear_qualities() {
  qualities_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EdgePileup::qualities() const {
  // @@protoc_insertion_point(field_get:vg.EdgePileup.qualities)
  return qualities_.GetNoArena();
}
inline void EdgePileup::set_qualities(const ::std::string& value) {
  
  qualities_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.EdgePileup.qualities)
}
#if LANG_CXX11
inline void EdgePileup::set_qualities(::std::string&& value) {
  
  qualities_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vg.EdgePileup.qualities)
}
#endif
inline void EdgePileup::set_qualities(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  qualities_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.EdgePileup.qualities)
}
inline void EdgePileup::set_qualities(const void* value, size_t size) {
  
  qualities_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.EdgePileup.qualities)
}
inline ::std::string* EdgePileup::mutable_qualities() {
  
  // @@protoc_insertion_point(field_mutable:vg.EdgePileup.qualities)
  return qualities_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EdgePileup::release_qualities() {
  // @@protoc_insertion_point(field_release:vg.EdgePileup.qualities)
  
  return qualities_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EdgePileup::set_allocated_qualities(::std::string* qualities) {
  if (qualities != NULL) {
    
  } else {
    
  }
  qualities_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), qualities);
  // @@protoc_insertion_point(field_set_allocated:vg.EdgePileup.qualities)
}

// -------------------------------------------------------------------

// Pileup

// repeated .vg.NodePileup node_pileups = 1;
inline int Pileup::node_pileups_size() const {
  return node_pileups_.size();
}
inline void Pileup::clear_node_pileups() {
  node_pileups_.Clear();
}
inline ::vg::NodePileup* Pileup::mutable_node_pileups(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Pileup.node_pileups)
  return node_pileups_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vg::NodePileup >*
Pileup::mutable_node_pileups() {
  // @@protoc_insertion_point(field_mutable_list:vg.Pileup.node_pileups)
  return &node_pileups_;
}
inline const ::vg::NodePileup& Pileup::node_pileups(int index) const {
  // @@protoc_insertion_point(field_get:vg.Pileup.node_pileups)
  return node_pileups_.Get(index);
}
inline ::vg::NodePileup* Pileup::add_node_pileups() {
  // @@protoc_insertion_point(field_add:vg.Pileup.node_pileups)
  return node_pileups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::NodePileup >&
Pileup::node_pileups() const {
  // @@protoc_insertion_point(field_list:vg.Pileup.node_pileups)
  return node_pileups_;
}

// repeated .vg.EdgePileup edge_pileups = 2;
inline int Pileup::edge_pileups_size() const {
  return edge_pileups_.size();
}
inline void Pileup::clear_edge_pileups() {
  edge_pileups_.Clear();
}
inline ::vg::EdgePileup* Pileup::mutable_edge_pileups(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Pileup.edge_pileups)
  return edge_pileups_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vg::EdgePileup >*
Pileup::mutable_edge_pileups() {
  // @@protoc_insertion_point(field_mutable_list:vg.Pileup.edge_pileups)
  return &edge_pileups_;
}
inline const ::vg::EdgePileup& Pileup::edge_pileups(int index) const {
  // @@protoc_insertion_point(field_get:vg.Pileup.edge_pileups)
  return edge_pileups_.Get(index);
}
inline ::vg::EdgePileup* Pileup::add_edge_pileups() {
  // @@protoc_insertion_point(field_add:vg.Pileup.edge_pileups)
  return edge_pileups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::EdgePileup >&
Pileup::edge_pileups() const {
  // @@protoc_insertion_point(field_list:vg.Pileup.edge_pileups)
  return edge_pileups_;
}

// -------------------------------------------------------------------

// Snarl

// .vg.SnarlType type = 1;
inline void Snarl::clear_type() {
  type_ = 0;
}
inline ::vg::SnarlType Snarl::type() const {
  // @@protoc_insertion_point(field_get:vg.Snarl.type)
  return static_cast< ::vg::SnarlType >(type_);
}
inline void Snarl::set_type(::vg::SnarlType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:vg.Snarl.type)
}

// .vg.Visit start = 2;
inline bool Snarl::has_start() const {
  return this != internal_default_instance() && start_ != NULL;
}
inline void Snarl::clear_start() {
  if (GetArenaNoVirtual() == NULL && start_ != NULL) {
    delete start_;
  }
  start_ = NULL;
}
inline const ::vg::Visit& Snarl::_internal_start() const {
  return *start_;
}
inline const ::vg::Visit& Snarl::start() const {
  const ::vg::Visit* p = start_;
  // @@protoc_insertion_point(field_get:vg.Snarl.start)
  return p != NULL ? *p : *reinterpret_cast<const ::vg::Visit*>(
      &::vg::_Visit_default_instance_);
}
inline ::vg::Visit* Snarl::release_start() {
  // @@protoc_insertion_point(field_release:vg.Snarl.start)
  
  ::vg::Visit* temp = start_;
  start_ = NULL;
  return temp;
}
inline ::vg::Visit* Snarl::mutable_start() {
  
  if (start_ == NULL) {
    auto* p = CreateMaybeMessage<::vg::Visit>(GetArenaNoVirtual());
    start_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vg.Snarl.start)
  return start_;
}
inline void Snarl::set_allocated_start(::vg::Visit* start) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete start_;
  }
  if (start) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      start = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    
  } else {
    
  }
  start_ = start;
  // @@protoc_insertion_point(field_set_allocated:vg.Snarl.start)
}

// .vg.Visit end = 3;
inline bool Snarl::has_end() const {
  return this != internal_default_instance() && end_ != NULL;
}
inline void Snarl::clear_end() {
  if (GetArenaNoVirtual() == NULL && end_ != NULL) {
    delete end_;
  }
  end_ = NULL;
}
inline const ::vg::Visit& Snarl::_internal_end() const {
  return *end_;
}
inline const ::vg::Visit& Snarl::end() const {
  const ::vg::Visit* p = end_;
  // @@protoc_insertion_point(field_get:vg.Snarl.end)
  return p != NULL ? *p : *reinterpret_cast<const ::vg::Visit*>(
      &::vg::_Visit_default_instance_);
}
inline ::vg::Visit* Snarl::release_end() {
  // @@protoc_insertion_point(field_release:vg.Snarl.end)
  
  ::vg::Visit* temp = end_;
  end_ = NULL;
  return temp;
}
inline ::vg::Visit* Snarl::mutable_end() {
  
  if (end_ == NULL) {
    auto* p = CreateMaybeMessage<::vg::Visit>(GetArenaNoVirtual());
    end_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vg.Snarl.end)
  return end_;
}
inline void Snarl::set_allocated_end(::vg::Visit* end) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete end_;
  }
  if (end) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      end = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    
  } else {
    
  }
  end_ = end;
  // @@protoc_insertion_point(field_set_allocated:vg.Snarl.end)
}

// .vg.Snarl parent = 4;
inline bool Snarl::has_parent() const {
  return this != internal_default_instance() && parent_ != NULL;
}
inline void Snarl::clear_parent() {
  if (GetArenaNoVirtual() == NULL && parent_ != NULL) {
    delete parent_;
  }
  parent_ = NULL;
}
inline const ::vg::Snarl& Snarl::_internal_parent() const {
  return *parent_;
}
inline const ::vg::Snarl& Snarl::parent() const {
  const ::vg::Snarl* p = parent_;
  // @@protoc_insertion_point(field_get:vg.Snarl.parent)
  return p != NULL ? *p : *reinterpret_cast<const ::vg::Snarl*>(
      &::vg::_Snarl_default_instance_);
}
inline ::vg::Snarl* Snarl::release_parent() {
  // @@protoc_insertion_point(field_release:vg.Snarl.parent)
  
  ::vg::Snarl* temp = parent_;
  parent_ = NULL;
  return temp;
}
inline ::vg::Snarl* Snarl::mutable_parent() {
  
  if (parent_ == NULL) {
    auto* p = CreateMaybeMessage<::vg::Snarl>(GetArenaNoVirtual());
    parent_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vg.Snarl.parent)
  return parent_;
}
inline void Snarl::set_allocated_parent(::vg::Snarl* parent) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete parent_;
  }
  if (parent) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      parent = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    
  } else {
    
  }
  parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:vg.Snarl.parent)
}

// string name = 5;
inline void Snarl::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Snarl::name() const {
  // @@protoc_insertion_point(field_get:vg.Snarl.name)
  return name_.GetNoArena();
}
inline void Snarl::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Snarl.name)
}
#if LANG_CXX11
inline void Snarl::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vg.Snarl.name)
}
#endif
inline void Snarl::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Snarl.name)
}
inline void Snarl::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Snarl.name)
}
inline ::std::string* Snarl::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:vg.Snarl.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Snarl::release_name() {
  // @@protoc_insertion_point(field_release:vg.Snarl.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Snarl::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vg.Snarl.name)
}

// bool start_self_reachable = 6;
inline void Snarl::clear_start_self_reachable() {
  start_self_reachable_ = false;
}
inline bool Snarl::start_self_reachable() const {
  // @@protoc_insertion_point(field_get:vg.Snarl.start_self_reachable)
  return start_self_reachable_;
}
inline void Snarl::set_start_self_reachable(bool value) {
  
  start_self_reachable_ = value;
  // @@protoc_insertion_point(field_set:vg.Snarl.start_self_reachable)
}

// bool end_self_reachable = 7;
inline void Snarl::clear_end_self_reachable() {
  end_self_reachable_ = false;
}
inline bool Snarl::end_self_reachable() const {
  // @@protoc_insertion_point(field_get:vg.Snarl.end_self_reachable)
  return end_self_reachable_;
}
inline void Snarl::set_end_self_reachable(bool value) {
  
  end_self_reachable_ = value;
  // @@protoc_insertion_point(field_set:vg.Snarl.end_self_reachable)
}

// bool start_end_reachable = 8;
inline void Snarl::clear_start_end_reachable() {
  start_end_reachable_ = false;
}
inline bool Snarl::start_end_reachable() const {
  // @@protoc_insertion_point(field_get:vg.Snarl.start_end_reachable)
  return start_end_reachable_;
}
inline void Snarl::set_start_end_reachable(bool value) {
  
  start_end_reachable_ = value;
  // @@protoc_insertion_point(field_set:vg.Snarl.start_end_reachable)
}

// bool directed_acyclic_net_graph = 9;
inline void Snarl::clear_directed_acyclic_net_graph() {
  directed_acyclic_net_graph_ = false;
}
inline bool Snarl::directed_acyclic_net_graph() const {
  // @@protoc_insertion_point(field_get:vg.Snarl.directed_acyclic_net_graph)
  return directed_acyclic_net_graph_;
}
inline void Snarl::set_directed_acyclic_net_graph(bool value) {
  
  directed_acyclic_net_graph_ = value;
  // @@protoc_insertion_point(field_set:vg.Snarl.directed_acyclic_net_graph)
}

// -------------------------------------------------------------------

// Visit

// int64 node_id = 1;
inline void Visit::clear_node_id() {
  node_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Visit::node_id() const {
  // @@protoc_insertion_point(field_get:vg.Visit.node_id)
  return node_id_;
}
inline void Visit::set_node_id(::google::protobuf::int64 value) {
  
  node_id_ = value;
  // @@protoc_insertion_point(field_set:vg.Visit.node_id)
}

// .vg.Snarl snarl = 2;
inline bool Visit::has_snarl() const {
  return this != internal_default_instance() && snarl_ != NULL;
}
inline void Visit::clear_snarl() {
  if (GetArenaNoVirtual() == NULL && snarl_ != NULL) {
    delete snarl_;
  }
  snarl_ = NULL;
}
inline const ::vg::Snarl& Visit::_internal_snarl() const {
  return *snarl_;
}
inline const ::vg::Snarl& Visit::snarl() const {
  const ::vg::Snarl* p = snarl_;
  // @@protoc_insertion_point(field_get:vg.Visit.snarl)
  return p != NULL ? *p : *reinterpret_cast<const ::vg::Snarl*>(
      &::vg::_Snarl_default_instance_);
}
inline ::vg::Snarl* Visit::release_snarl() {
  // @@protoc_insertion_point(field_release:vg.Visit.snarl)
  
  ::vg::Snarl* temp = snarl_;
  snarl_ = NULL;
  return temp;
}
inline ::vg::Snarl* Visit::mutable_snarl() {
  
  if (snarl_ == NULL) {
    auto* p = CreateMaybeMessage<::vg::Snarl>(GetArenaNoVirtual());
    snarl_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vg.Visit.snarl)
  return snarl_;
}
inline void Visit::set_allocated_snarl(::vg::Snarl* snarl) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete snarl_;
  }
  if (snarl) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      snarl = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, snarl, submessage_arena);
    }
    
  } else {
    
  }
  snarl_ = snarl;
  // @@protoc_insertion_point(field_set_allocated:vg.Visit.snarl)
}

// bool backward = 3;
inline void Visit::clear_backward() {
  backward_ = false;
}
inline bool Visit::backward() const {
  // @@protoc_insertion_point(field_get:vg.Visit.backward)
  return backward_;
}
inline void Visit::set_backward(bool value) {
  
  backward_ = value;
  // @@protoc_insertion_point(field_set:vg.Visit.backward)
}

// -------------------------------------------------------------------

// SnarlTraversal

// repeated .vg.Visit visit = 1;
inline int SnarlTraversal::visit_size() const {
  return visit_.size();
}
inline void SnarlTraversal::clear_visit() {
  visit_.Clear();
}
inline ::vg::Visit* SnarlTraversal::mutable_visit(int index) {
  // @@protoc_insertion_point(field_mutable:vg.SnarlTraversal.visit)
  return visit_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Visit >*
SnarlTraversal::mutable_visit() {
  // @@protoc_insertion_point(field_mutable_list:vg.SnarlTraversal.visit)
  return &visit_;
}
inline const ::vg::Visit& SnarlTraversal::visit(int index) const {
  // @@protoc_insertion_point(field_get:vg.SnarlTraversal.visit)
  return visit_.Get(index);
}
inline ::vg::Visit* SnarlTraversal::add_visit() {
  // @@protoc_insertion_point(field_add:vg.SnarlTraversal.visit)
  return visit_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Visit >&
SnarlTraversal::visit() const {
  // @@protoc_insertion_point(field_list:vg.SnarlTraversal.visit)
  return visit_;
}

// string name = 2;
inline void SnarlTraversal::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SnarlTraversal::name() const {
  // @@protoc_insertion_point(field_get:vg.SnarlTraversal.name)
  return name_.GetNoArena();
}
inline void SnarlTraversal::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.SnarlTraversal.name)
}
#if LANG_CXX11
inline void SnarlTraversal::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vg.SnarlTraversal.name)
}
#endif
inline void SnarlTraversal::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.SnarlTraversal.name)
}
inline void SnarlTraversal::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.SnarlTraversal.name)
}
inline ::std::string* SnarlTraversal::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:vg.SnarlTraversal.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SnarlTraversal::release_name() {
  // @@protoc_insertion_point(field_release:vg.SnarlTraversal.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SnarlTraversal::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vg.SnarlTraversal.name)
}

// -------------------------------------------------------------------

// Locus

// string name = 1;
inline void Locus::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Locus::name() const {
  // @@protoc_insertion_point(field_get:vg.Locus.name)
  return name_.GetNoArena();
}
inline void Locus::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Locus.name)
}
#if LANG_CXX11
inline void Locus::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vg.Locus.name)
}
#endif
inline void Locus::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Locus.name)
}
inline void Locus::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Locus.name)
}
inline ::std::string* Locus::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:vg.Locus.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Locus::release_name() {
  // @@protoc_insertion_point(field_release:vg.Locus.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Locus::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vg.Locus.name)
}

// repeated .vg.Path allele = 2;
inline int Locus::allele_size() const {
  return allele_.size();
}
inline void Locus::clear_allele() {
  allele_.Clear();
}
inline ::vg::Path* Locus::mutable_allele(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Locus.allele)
  return allele_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Path >*
Locus::mutable_allele() {
  // @@protoc_insertion_point(field_mutable_list:vg.Locus.allele)
  return &allele_;
}
inline const ::vg::Path& Locus::allele(int index) const {
  // @@protoc_insertion_point(field_get:vg.Locus.allele)
  return allele_.Get(index);
}
inline ::vg::Path* Locus::add_allele() {
  // @@protoc_insertion_point(field_add:vg.Locus.allele)
  return allele_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Path >&
Locus::allele() const {
  // @@protoc_insertion_point(field_list:vg.Locus.allele)
  return allele_;
}

// repeated .vg.Support support = 3;
inline int Locus::support_size() const {
  return support_.size();
}
inline void Locus::clear_support() {
  support_.Clear();
}
inline ::vg::Support* Locus::mutable_support(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Locus.support)
  return support_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Support >*
Locus::mutable_support() {
  // @@protoc_insertion_point(field_mutable_list:vg.Locus.support)
  return &support_;
}
inline const ::vg::Support& Locus::support(int index) const {
  // @@protoc_insertion_point(field_get:vg.Locus.support)
  return support_.Get(index);
}
inline ::vg::Support* Locus::add_support() {
  // @@protoc_insertion_point(field_add:vg.Locus.support)
  return support_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Support >&
Locus::support() const {
  // @@protoc_insertion_point(field_list:vg.Locus.support)
  return support_;
}

// repeated .vg.Genotype genotype = 4;
inline int Locus::genotype_size() const {
  return genotype_.size();
}
inline void Locus::clear_genotype() {
  genotype_.Clear();
}
inline ::vg::Genotype* Locus::mutable_genotype(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Locus.genotype)
  return genotype_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Genotype >*
Locus::mutable_genotype() {
  // @@protoc_insertion_point(field_mutable_list:vg.Locus.genotype)
  return &genotype_;
}
inline const ::vg::Genotype& Locus::genotype(int index) const {
  // @@protoc_insertion_point(field_get:vg.Locus.genotype)
  return genotype_.Get(index);
}
inline ::vg::Genotype* Locus::add_genotype() {
  // @@protoc_insertion_point(field_add:vg.Locus.genotype)
  return genotype_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Genotype >&
Locus::genotype() const {
  // @@protoc_insertion_point(field_list:vg.Locus.genotype)
  return genotype_;
}

// .vg.Support overall_support = 5;
inline bool Locus::has_overall_support() const {
  return this != internal_default_instance() && overall_support_ != NULL;
}
inline void Locus::clear_overall_support() {
  if (GetArenaNoVirtual() == NULL && overall_support_ != NULL) {
    delete overall_support_;
  }
  overall_support_ = NULL;
}
inline const ::vg::Support& Locus::_internal_overall_support() const {
  return *overall_support_;
}
inline const ::vg::Support& Locus::overall_support() const {
  const ::vg::Support* p = overall_support_;
  // @@protoc_insertion_point(field_get:vg.Locus.overall_support)
  return p != NULL ? *p : *reinterpret_cast<const ::vg::Support*>(
      &::vg::_Support_default_instance_);
}
inline ::vg::Support* Locus::release_overall_support() {
  // @@protoc_insertion_point(field_release:vg.Locus.overall_support)
  
  ::vg::Support* temp = overall_support_;
  overall_support_ = NULL;
  return temp;
}
inline ::vg::Support* Locus::mutable_overall_support() {
  
  if (overall_support_ == NULL) {
    auto* p = CreateMaybeMessage<::vg::Support>(GetArenaNoVirtual());
    overall_support_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vg.Locus.overall_support)
  return overall_support_;
}
inline void Locus::set_allocated_overall_support(::vg::Support* overall_support) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete overall_support_;
  }
  if (overall_support) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      overall_support = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, overall_support, submessage_arena);
    }
    
  } else {
    
  }
  overall_support_ = overall_support;
  // @@protoc_insertion_point(field_set_allocated:vg.Locus.overall_support)
}

// repeated double allele_log_likelihood = 6;
inline int Locus::allele_log_likelihood_size() const {
  return allele_log_likelihood_.size();
}
inline void Locus::clear_allele_log_likelihood() {
  allele_log_likelihood_.Clear();
}
inline double Locus::allele_log_likelihood(int index) const {
  // @@protoc_insertion_point(field_get:vg.Locus.allele_log_likelihood)
  return allele_log_likelihood_.Get(index);
}
inline void Locus::set_allele_log_likelihood(int index, double value) {
  allele_log_likelihood_.Set(index, value);
  // @@protoc_insertion_point(field_set:vg.Locus.allele_log_likelihood)
}
inline void Locus::add_allele_log_likelihood(double value) {
  allele_log_likelihood_.Add(value);
  // @@protoc_insertion_point(field_add:vg.Locus.allele_log_likelihood)
}
inline const ::google::protobuf::RepeatedField< double >&
Locus::allele_log_likelihood() const {
  // @@protoc_insertion_point(field_list:vg.Locus.allele_log_likelihood)
  return allele_log_likelihood_;
}
inline ::google::protobuf::RepeatedField< double >*
Locus::mutable_allele_log_likelihood() {
  // @@protoc_insertion_point(field_mutable_list:vg.Locus.allele_log_likelihood)
  return &allele_log_likelihood_;
}

// -------------------------------------------------------------------

// Genotype

// repeated int32 allele = 1;
inline int Genotype::allele_size() const {
  return allele_.size();
}
inline void Genotype::clear_allele() {
  allele_.Clear();
}
inline ::google::protobuf::int32 Genotype::allele(int index) const {
  // @@protoc_insertion_point(field_get:vg.Genotype.allele)
  return allele_.Get(index);
}
inline void Genotype::set_allele(int index, ::google::protobuf::int32 value) {
  allele_.Set(index, value);
  // @@protoc_insertion_point(field_set:vg.Genotype.allele)
}
inline void Genotype::add_allele(::google::protobuf::int32 value) {
  allele_.Add(value);
  // @@protoc_insertion_point(field_add:vg.Genotype.allele)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Genotype::allele() const {
  // @@protoc_insertion_point(field_list:vg.Genotype.allele)
  return allele_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Genotype::mutable_allele() {
  // @@protoc_insertion_point(field_mutable_list:vg.Genotype.allele)
  return &allele_;
}

// bool is_phased = 2;
inline void Genotype::clear_is_phased() {
  is_phased_ = false;
}
inline bool Genotype::is_phased() const {
  // @@protoc_insertion_point(field_get:vg.Genotype.is_phased)
  return is_phased_;
}
inline void Genotype::set_is_phased(bool value) {
  
  is_phased_ = value;
  // @@protoc_insertion_point(field_set:vg.Genotype.is_phased)
}

// double likelihood = 3;
inline void Genotype::clear_likelihood() {
  likelihood_ = 0;
}
inline double Genotype::likelihood() const {
  // @@protoc_insertion_point(field_get:vg.Genotype.likelihood)
  return likelihood_;
}
inline void Genotype::set_likelihood(double value) {
  
  likelihood_ = value;
  // @@protoc_insertion_point(field_set:vg.Genotype.likelihood)
}

// double log_likelihood = 4;
inline void Genotype::clear_log_likelihood() {
  log_likelihood_ = 0;
}
inline double Genotype::log_likelihood() const {
  // @@protoc_insertion_point(field_get:vg.Genotype.log_likelihood)
  return log_likelihood_;
}
inline void Genotype::set_log_likelihood(double value) {
  
  log_likelihood_ = value;
  // @@protoc_insertion_point(field_set:vg.Genotype.log_likelihood)
}

// double log_prior = 5;
inline void Genotype::clear_log_prior() {
  log_prior_ = 0;
}
inline double Genotype::log_prior() const {
  // @@protoc_insertion_point(field_get:vg.Genotype.log_prior)
  return log_prior_;
}
inline void Genotype::set_log_prior(double value) {
  
  log_prior_ = value;
  // @@protoc_insertion_point(field_set:vg.Genotype.log_prior)
}

// double log_posterior = 6;
inline void Genotype::clear_log_posterior() {
  log_posterior_ = 0;
}
inline double Genotype::log_posterior() const {
  // @@protoc_insertion_point(field_get:vg.Genotype.log_posterior)
  return log_posterior_;
}
inline void Genotype::set_log_posterior(double value) {
  
  log_posterior_ = value;
  // @@protoc_insertion_point(field_set:vg.Genotype.log_posterior)
}

// -------------------------------------------------------------------

// Support

// double quality = 1;
inline void Support::clear_quality() {
  quality_ = 0;
}
inline double Support::quality() const {
  // @@protoc_insertion_point(field_get:vg.Support.quality)
  return quality_;
}
inline void Support::set_quality(double value) {
  
  quality_ = value;
  // @@protoc_insertion_point(field_set:vg.Support.quality)
}

// double forward = 2;
inline void Support::clear_forward() {
  forward_ = 0;
}
inline double Support::forward() const {
  // @@protoc_insertion_point(field_get:vg.Support.forward)
  return forward_;
}
inline void Support::set_forward(double value) {
  
  forward_ = value;
  // @@protoc_insertion_point(field_set:vg.Support.forward)
}

// double reverse = 3;
inline void Support::clear_reverse() {
  reverse_ = 0;
}
inline double Support::reverse() const {
  // @@protoc_insertion_point(field_get:vg.Support.reverse)
  return reverse_;
}
inline void Support::set_reverse(double value) {
  
  reverse_ = value;
  // @@protoc_insertion_point(field_set:vg.Support.reverse)
}

// double left = 4;
inline void Support::clear_left() {
  left_ = 0;
}
inline double Support::left() const {
  // @@protoc_insertion_point(field_get:vg.Support.left)
  return left_;
}
inline void Support::set_left(double value) {
  
  left_ = value;
  // @@protoc_insertion_point(field_set:vg.Support.left)
}

// double right = 5;
inline void Support::clear_right() {
  right_ = 0;
}
inline double Support::right() const {
  // @@protoc_insertion_point(field_get:vg.Support.right)
  return right_;
}
inline void Support::set_right(double value) {
  
  right_ = value;
  // @@protoc_insertion_point(field_set:vg.Support.right)
}

// -------------------------------------------------------------------

// LocationSupport

// .vg.Support support = 1;
inline bool LocationSupport::has_support() const {
  return this != internal_default_instance() && support_ != NULL;
}
inline void LocationSupport::clear_support() {
  if (GetArenaNoVirtual() == NULL && support_ != NULL) {
    delete support_;
  }
  support_ = NULL;
}
inline const ::vg::Support& LocationSupport::_internal_support() const {
  return *support_;
}
inline const ::vg::Support& LocationSupport::support() const {
  const ::vg::Support* p = support_;
  // @@protoc_insertion_point(field_get:vg.LocationSupport.support)
  return p != NULL ? *p : *reinterpret_cast<const ::vg::Support*>(
      &::vg::_Support_default_instance_);
}
inline ::vg::Support* LocationSupport::release_support() {
  // @@protoc_insertion_point(field_release:vg.LocationSupport.support)
  
  ::vg::Support* temp = support_;
  support_ = NULL;
  return temp;
}
inline ::vg::Support* LocationSupport::mutable_support() {
  
  if (support_ == NULL) {
    auto* p = CreateMaybeMessage<::vg::Support>(GetArenaNoVirtual());
    support_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vg.LocationSupport.support)
  return support_;
}
inline void LocationSupport::set_allocated_support(::vg::Support* support) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete support_;
  }
  if (support) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      support = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, support, submessage_arena);
    }
    
  } else {
    
  }
  support_ = support;
  // @@protoc_insertion_point(field_set_allocated:vg.LocationSupport.support)
}

// .vg.Edge edge = 2;
inline bool LocationSupport::has_edge() const {
  return oneof_location_case() == kEdge;
}
inline void LocationSupport::set_has_edge() {
  _oneof_case_[0] = kEdge;
}
inline void LocationSupport::clear_edge() {
  if (has_edge()) {
    delete oneof_location_.edge_;
    clear_has_oneof_location();
  }
}
inline const ::vg::Edge& LocationSupport::_internal_edge() const {
  return *oneof_location_.edge_;
}
inline ::vg::Edge* LocationSupport::release_edge() {
  // @@protoc_insertion_point(field_release:vg.LocationSupport.edge)
  if (has_edge()) {
    clear_has_oneof_location();
      ::vg::Edge* temp = oneof_location_.edge_;
    oneof_location_.edge_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vg::Edge& LocationSupport::edge() const {
  // @@protoc_insertion_point(field_get:vg.LocationSupport.edge)
  return has_edge()
      ? *oneof_location_.edge_
      : *reinterpret_cast< ::vg::Edge*>(&::vg::_Edge_default_instance_);
}
inline ::vg::Edge* LocationSupport::mutable_edge() {
  if (!has_edge()) {
    clear_oneof_location();
    set_has_edge();
    oneof_location_.edge_ = CreateMaybeMessage< ::vg::Edge >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vg.LocationSupport.edge)
  return oneof_location_.edge_;
}

// int64 node_id = 3;
inline bool LocationSupport::has_node_id() const {
  return oneof_location_case() == kNodeId;
}
inline void LocationSupport::set_has_node_id() {
  _oneof_case_[0] = kNodeId;
}
inline void LocationSupport::clear_node_id() {
  if (has_node_id()) {
    oneof_location_.node_id_ = GOOGLE_LONGLONG(0);
    clear_has_oneof_location();
  }
}
inline ::google::protobuf::int64 LocationSupport::node_id() const {
  // @@protoc_insertion_point(field_get:vg.LocationSupport.node_id)
  if (has_node_id()) {
    return oneof_location_.node_id_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void LocationSupport::set_node_id(::google::protobuf::int64 value) {
  if (!has_node_id()) {
    clear_oneof_location();
    set_has_node_id();
  }
  oneof_location_.node_id_ = value;
  // @@protoc_insertion_point(field_set:vg.LocationSupport.node_id)
}

inline bool LocationSupport::has_oneof_location() const {
  return oneof_location_case() != ONEOF_LOCATION_NOT_SET;
}
inline void LocationSupport::clear_has_oneof_location() {
  _oneof_case_[0] = ONEOF_LOCATION_NOT_SET;
}
inline LocationSupport::OneofLocationCase LocationSupport::oneof_location_case() const {
  return LocationSupport::OneofLocationCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Translation

// .vg.Path from = 1;
inline bool Translation::has_from() const {
  return this != internal_default_instance() && from_ != NULL;
}
inline void Translation::clear_from() {
  if (GetArenaNoVirtual() == NULL && from_ != NULL) {
    delete from_;
  }
  from_ = NULL;
}
inline const ::vg::Path& Translation::_internal_from() const {
  return *from_;
}
inline const ::vg::Path& Translation::from() const {
  const ::vg::Path* p = from_;
  // @@protoc_insertion_point(field_get:vg.Translation.from)
  return p != NULL ? *p : *reinterpret_cast<const ::vg::Path*>(
      &::vg::_Path_default_instance_);
}
inline ::vg::Path* Translation::release_from() {
  // @@protoc_insertion_point(field_release:vg.Translation.from)
  
  ::vg::Path* temp = from_;
  from_ = NULL;
  return temp;
}
inline ::vg::Path* Translation::mutable_from() {
  
  if (from_ == NULL) {
    auto* p = CreateMaybeMessage<::vg::Path>(GetArenaNoVirtual());
    from_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vg.Translation.from)
  return from_;
}
inline void Translation::set_allocated_from(::vg::Path* from) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete from_;
  }
  if (from) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      from = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, from, submessage_arena);
    }
    
  } else {
    
  }
  from_ = from;
  // @@protoc_insertion_point(field_set_allocated:vg.Translation.from)
}

// .vg.Path to = 2;
inline bool Translation::has_to() const {
  return this != internal_default_instance() && to_ != NULL;
}
inline void Translation::clear_to() {
  if (GetArenaNoVirtual() == NULL && to_ != NULL) {
    delete to_;
  }
  to_ = NULL;
}
inline const ::vg::Path& Translation::_internal_to() const {
  return *to_;
}
inline const ::vg::Path& Translation::to() const {
  const ::vg::Path* p = to_;
  // @@protoc_insertion_point(field_get:vg.Translation.to)
  return p != NULL ? *p : *reinterpret_cast<const ::vg::Path*>(
      &::vg::_Path_default_instance_);
}
inline ::vg::Path* Translation::release_to() {
  // @@protoc_insertion_point(field_release:vg.Translation.to)
  
  ::vg::Path* temp = to_;
  to_ = NULL;
  return temp;
}
inline ::vg::Path* Translation::mutable_to() {
  
  if (to_ == NULL) {
    auto* p = CreateMaybeMessage<::vg::Path>(GetArenaNoVirtual());
    to_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vg.Translation.to)
  return to_;
}
inline void Translation::set_allocated_to(::vg::Path* to) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete to_;
  }
  if (to) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      to = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, to, submessage_arena);
    }
    
  } else {
    
  }
  to_ = to;
  // @@protoc_insertion_point(field_set_allocated:vg.Translation.to)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace vg

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::vg::SnarlType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vg::SnarlType>() {
  return ::vg::SnarlType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_vg_2eproto
